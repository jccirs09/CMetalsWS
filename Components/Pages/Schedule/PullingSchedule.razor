@page "/schedule/pulling"
@using MudBlazor
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.SignalR.Client
@using CMetalsWS.Data
@using CMetalsWS.Services
@using CMetalsWS.Security
@attribute [Authorize(Policy = Permissions.WorkOrders.Schedule)]

@inject PickingListService PickingListService
@inject MachineService MachineService
@inject BranchService BranchService
@inject AuthenticationStateProvider AuthStateProvider
@inject NavigationManager NavigationManager
@inject ISnackbar Snackbar

@implements IAsyncDisposable

<MudPaper Class="pa-4">
    <MudStack Spacing="3">
        <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
            <MudText Typo="Typo.h5">Pulling Schedule</MudText>
        </MudStack>

        <MudDropContainer @ref="_container" T="PickingListItem" Items="_items" ItemsSelector="@((item,zone) => item.MachineId.ToString() == zone)" ItemDropped="ItemDropped" Class="d-flex flex-wrap flex-grow-1">
            <ItemRenderer>
                <MudPaper Class="pa-4 my-2">
                    <MudText Typo="Typo.body1">@context.PickingList.SalesOrderNumber</MudText>
                    <MudText Typo="Typo.body2">@context.PickingList.Customer?.CustomerName</MudText>
                </MudPaper>
            </ItemRenderer>
            <ChildContent>
                <div class="d-flex flex-wrap">
                    @foreach (var machine in _machines)
                    {
                        <MudPaper Class="pa-6 ma-2 mud-border-dotted">
                            <MudText Typo="Typo.h6" Class="mb-4">@machine.Name</MudText>
                            <MudDropZone T="PickingListItem" Identifier="@(machine.Id.ToString())" />
                        </MudPaper>
                    }
                </div>
            </ChildContent>
        </MudDropContainer>
    </MudStack>
</MudPaper>

@code {
    private List<PickingListItem> _items = new();
    private List<Machine> _machines = new();
    private MudDropContainer<PickingListItem> _container = new();
    private HubConnection? _hub;

    protected override async Task OnInitializedAsync()
    {
        var auth = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = auth.User;
        var branches = await BranchService.GetBranchesAsync();
        int? branchId = user.IsInRole("Admin") ? null : branches.FirstOrDefault()?.Id;

        await LoadData(branchId);

        _hub = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/schedule"))
            .WithAutomaticReconnect()
            .Build();

        _hub.On<int>("PickingListUpdated", async _ =>
        {
            await InvokeAsync(async () =>
            {
                await LoadData(branchId);
                StateHasChanged();
            });
        });

        await _hub.StartAsync();
    }

    private async Task LoadData(int? branchId)
    {
        _machines = (await MachineService.GetMachinesAsync()).Where(m => m.Category == MachineCategory.Sheet).ToList();
        _items = await PickingListService.GetSheetPullingQueueAsync();
        if (branchId.HasValue)
        {
            _items = _items.Where(i => i.PickingList?.BranchId == branchId.Value).ToList();
        }
    }

    private async Task ItemDropped(MudItemDropInfo<PickingListItem> dropItem)
    {
        var itemToMove = dropItem.Item;
        var newZoneId = dropItem.DropzoneIdentifier;
        var indexInNewZone = dropItem.IndexInZone;

        // Update the item's machine association
        itemToMove.MachineId = int.Parse(newZoneId);

        // Manually re-order the backing list to match the UI state
        _items.Remove(itemToMove);

        var itemsInNewZone = _items.Where(i => i.MachineId.ToString() == newZoneId).ToList();
        if (indexInNewZone < itemsInNewZone.Count)
        {
            // Insert before an existing item
            var itemToInsertBefore = itemsInNewZone[indexInNewZone];
            var globalIndex = _items.IndexOf(itemToInsertBefore);
            _items.Insert(globalIndex, itemToMove);
        }
        else
        {
            // Insert at the end of the zone
            if (itemsInNewZone.Any())
            {
                var lastItemInZone = itemsInNewZone.Last();
                var globalIndex = _items.IndexOf(lastItemInZone);
                _items.Insert(globalIndex + 1, itemToMove);
            }
            else // Dropped into an empty zone
            {
                // Find the first item of the next zone and insert before it
                var machineZoneIds = _machines.Select(m => m.Id.ToString()).ToList();
                var zoneIndex = machineZoneIds.IndexOf(newZoneId);
                int insertionIndex = _items.Count; // Default to end of list

                for (int i = zoneIndex + 1; i < machineZoneIds.Count; i++)
                {
                    var nextZoneId = machineZoneIds[i];
                    var firstItemOfNextZone = _items.FirstOrDefault(it => it.MachineId.ToString() == nextZoneId);
                    if (firstItemOfNextZone != null)
                    {
                        insertionIndex = _items.IndexOf(firstItemOfNextZone);
                        break;
                    }
                }
                _items.Insert(insertionIndex, itemToMove);
            }
        }

        // Recalculate priorities for all machine groups
        var machineGroups = _items.GroupBy(i => i.MachineId);
        foreach (var group in machineGroups)
        {
            int priority = 0;
            foreach (var item in group)
            {
                item.PickingList.Priority = priority++;
            }
        }

        // Persist changes and update UI
        await PickingListService.UpdatePullingQueueAsync(_items);

        var machineName = _machines.FirstOrDefault(m => m.Id == itemToMove.MachineId)?.Name;
        Snackbar.Add($"Moved {itemToMove.PickingList.SalesOrderNumber} to machine {machineName}", Severity.Success);

        if (_hub is not null)
        {
            await _hub.SendAsync("PickingListUpdated", itemToMove.PickingListId);
        }

        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        if (_hub is not null)
            await _hub.DisposeAsync();
    }
}
