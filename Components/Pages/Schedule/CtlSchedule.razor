@page "/schedule/ctl"
@using System.Linq
@using MudBlazor
@using Heron.MudCalendar
@using Microsoft.AspNetCore.SignalR.Client
@using CMetalsWS.Data
@using CMetalsWS.Services

@inject WorkOrderService WorkOrderService
@inject MachineService MachineService
@inject BranchService BranchService
@inject AuthenticationStateProvider AuthStateProvider
@inject NavigationManager NavigationManager

@implements IAsyncDisposable

<MudPaper Class="pa-4">
    <MudStack Spacing="3">
        <MudStack Row AlignItems="AlignItems.Center" Spacing="2">
            <MudText Typo="Typo.h5">CTL Schedule</MudText>
            <MudSpacer />
            <MudSelect T="int" Label="Machine" @bind-Value="_selectedMachineId" Dense="true" Style="min-width:240px">
                @foreach (var m in _machines)
                {
                    <MudSelectItem T="int" Value="@m.Id">@m.Name</MudSelectItem>
                }
            </MudSelect>
        </MudStack>

        <MudGrid>
            <MudItem xs="12" sm="9">
                <MudCalendar T="SchedItem"
                             Items="_items"
                             View="_view"
                             MonthCellMinHeight="120"
                             EnableDragItems="true"
                             EnableResizeItems="true"
                             CanDragItem="@(it => it.Start >= DateTime.Now)"
                             CanDropItem="@((it, date, view) => (view == CalendarView.Month && date.Add(it.Start.TimeOfDay) >= DateTime.Now) || date >= DateTime.Now)"
                             onItemDrop="HandleDrop"
                             onItemClick="HandleClick">
                    <CellTemplate Context="evt">
                        @{
                            var wo = evt.WorkOrder!;
                            var stripe = "var(--mud-palette-primary)";
                            var sub = $"{wo.TagNumber} • Due {wo.DueDate:yyyy-MM-dd}";
                        }
                        <div style="width:100%;border:1px solid var(--mud-palette-lines-default);border-left:4px solid @stripe;border-radius:6px;overflow:hidden;">
                            <div style="display:flex;align-items:center;gap:.5rem;padding:.25rem .5rem;">
                                <MudIcon Icon="@Icons.Material.Filled.Build" Size="Size.Small" />
                                <MudText Typo="Typo.body2">@wo.WorkOrderNumber</MudText>
                                <MudSpacer />
                                <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined">WO @wo.Id</MudChip>
                            </div>
                            <div style="padding:0 .5rem .5rem .5rem;">
                                <MudText Typo="Typo.caption">@sub</MudText>
                            </div>
                        </div>
                    </CellTemplate>
                </MudCalendar>
            </MudItem>
            <MudItem xs="12" sm="3">
                <MudText Typo="Typo.h6">Unscheduled CTL Work Orders</MudText>
                <MudList T="WorkOrder" Dense="true">
                    @foreach (var wo in _unscheduled)
                    {
                        <MudListItem T="WorkOrder" Value="@wo">
                            @wo.WorkOrderNumber - @wo.TagNumber - Due: @wo.DueDate.ToString("yyyy-MM-dd")
                        </MudListItem>
                    }
                </MudList>
            </MudItem>
        </MudGrid>
    </MudStack>
</MudPaper>

@code {
    private sealed class SchedItem : CalendarItem
    {
        public WorkOrder WorkOrder { get; init; } = default!;
    }

    private List<Machine> _machines = new();
    private List<WorkOrder> _all = new();
    private List<WorkOrder> _unscheduled = new();
    private List<SchedItem> _items = new();

    private int _selectedMachineId;
    private CalendarView _view = CalendarView.Week;
    private HubConnection? _hub;

    protected override async Task OnInitializedAsync()
    {
        var auth = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = auth.User;
        var branches = await BranchService.GetBranchesAsync();
        int? branchId = user.IsInRole("Admin") ? null : branches.FirstOrDefault()?.Id;

        _machines = (await MachineService.GetMachinesAsync())
            .Where(m => m.Category == MachineCategory.CTL && (!branchId.HasValue || m.BranchId == branchId.Value))
            .ToList();

        if (_machines.Any())
            _selectedMachineId = _machines.First().Id;

        await LoadWorkOrders(branchId);
        BuildCalendarItems();

        _hub = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/schedule"))
            .WithAutomaticReconnect()
            .Build();

        _hub.On<int>("WorkOrderUpdated", async (id) =>
        {
            await LoadWorkOrders(branchId);
            BuildCalendarItems();
            StateHasChanged();
        });

        await _hub.StartAsync();
    }

    private async Task LoadWorkOrders(int? branchId)
    {
        _all = (await WorkOrderService.GetByCategoryAsync(MachineCategory.CTL, branchId))
            .Where(w => _selectedMachineId == 0 || w.MachineId == _selectedMachineId)
            .ToList();

        _unscheduled = _all.Where(w => w.ScheduledStartDate == null).ToList();
    }

    private void BuildCalendarItems()
    {
        _items = _all
            .Where(w => w.ScheduledStartDate != null)
            .Select(w => new SchedItem
            {
                Text = w.WorkOrderNumber,
                Start = w.ScheduledStartDate!.Value,
                End = w.ScheduledEndDate ?? w.ScheduledStartDate!.Value.AddHours(1),
                AllDay = false,
                WorkOrder = w
            })
            .ToList();
    }

    // Use dynamic to avoid direct dependency on ItemDropEventArgs<T>
    private async Task HandleDrop(object e)
    {
        dynamic d = e; // d.Item (SchedItem), d.NewStart (DateTime), d.NewEnd (DateTime?)
        var item = (SchedItem)d.Item;
        var newStart = (DateTime)d.NewStart;
        var newEnd = (DateTime?)(d.NewEnd ?? null) ?? newStart.AddHours(1);

        var wo = item.WorkOrder;
        wo.ScheduledStartDate = newStart;
        wo.ScheduledEndDate = newEnd;

        await WorkOrderService.UpdateAsync(wo, "system");
        // refresh from source to keep references consistent
        await LoadWorkOrders(null);
        BuildCalendarItems();
        StateHasChanged();

        if (_hub is not null)
            await _hub.SendAsync("WorkOrderUpdated", wo.Id);
    }

    private Task HandleClick(SchedItem item)
    {
        // Navigate to a WO details page if you have one (adjust route as needed)
         NavigationManager.NavigateTo($"/work-orders/{item.WorkOrder.Id}");
        return Task.CompletedTask;
    }

    public async ValueTask DisposeAsync()
    {
        if (_hub is not null)
            await _hub.DisposeAsync();
    }

    // React to machine change
    private async Task OnSelectedMachineChanged(int value)
    {
       
        await LoadWorkOrders(null);
        BuildCalendarItems();
        StateHasChanged();
    }
}
