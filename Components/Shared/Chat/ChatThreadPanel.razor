@using CMetalsWS.Data.Chat
@using CMetalsWS.Services
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims

@using CMetalsWS.Services.SignalR

@inject IChatRepository ChatRepository
@inject AuthenticationStateProvider AuthStateProvider
@inject ChatStateService ChatState
@inject ChatHubClient ChatHubClient

@implements IAsyncDisposable

<div class="d-flex flex-column" style="max-height: 400px;">
    <MudTextField @bind-Value="_searchQuery" Placeholder="Search messages..." Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" DebounceInterval="300" OnDebounceIntervalElapsed="Refresh" />
    <div class="flex-grow-1 overflow-y-auto">
        <MudList T="ThreadSummary" Clickable="true">
            <MudVirtualize @ref="_virtualizeRef" ItemsProvider="LoadThreads" T="ThreadSummary" Context="context">
                <ChildContent>
                    <MudListItem T="ThreadSummary" OnClick="@(() => OnThreadSelected.InvokeAsync(context))">
                        <MudBadge Color="Color.Primary" Overlap="true" Content="@context.UnreadCount" Visible="@(context.UnreadCount > 0)">
                            <MudAvatar>
                                <MudImage Src="@context.AvatarUrl" />
                            </MudAvatar>
                        </MudBadge>
                        <div class="ml-4 flex-grow-1">
                            <MudText>@context.Title</MudText>
                            <MudText Typo="Typo.caption">@context.LastMessagePreview</MudText>
                        </div>
                        <MudIconButton Icon="@(context.IsPinned ? Icons.Material.Filled.PushPin : Icons.Material.Outlined.PushPin)"
                                       Color="@(context.IsPinned ? Color.Primary : Color.Default)"
                                       OnClick="() => PinThread(context)" />
                    </MudListItem>
                </ChildContent>
            </MudVirtualize>
        </MudList>
    </div>
</div>

@code {
    private string _searchQuery = string.Empty;
    private string? _currentUserId;
    private MudVirtualize<ThreadSummary>? _virtualizeRef;

    [Parameter] public EventCallback<ThreadSummary> OnThreadSelected { get; set; }

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        _currentUserId = authState.User.FindFirstValue(ClaimTypes.NameIdentifier);
        ChatHubClient.ThreadsUpdated += OnThreadsUpdated;
    }

    private async Task Refresh()
    {
        if (_virtualizeRef != null)
        {
            await _virtualizeRef.RefreshDataAsync();
        }
    }

    private async Task OnThreadsUpdated()
    {
    await LoadThreads(new ItemsProviderRequest(0, 100, CancellationToken.None)); // Reload threads
        StateHasChanged();
    }

    private async Task PinThread(ThreadSummary thread)
    {
        await ChatHubClient.PinThreadAsync(thread.Id!, !thread.IsPinned);
    }

    private async ValueTask<ItemsProviderResult<ThreadSummary>> LoadThreads(ItemsProviderRequest request)
    {
        if (_currentUserId == null)
        {
            return new ItemsProviderResult<ThreadSummary>(new List<ThreadSummary>(), 0);
        }

        var summaries = (await ChatRepository.GetThreadSummariesAsync(_currentUserId, _searchQuery)).ToList();

        return new ItemsProviderResult<ThreadSummary>(
            summaries.Skip(request.StartIndex).Take(request.Count),
            summaries.Count
        );
    }

public async ValueTask DisposeAsync()
    {
        ChatHubClient.ThreadsUpdated -= OnThreadsUpdated;
    await Task.CompletedTask;
    }
}
