@using System.Security.Claims
@using CMetalsWS.Data.Chat
@using CMetalsWS.Services
@using CMetalsWS.Services.SignalR
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Web.Virtualization
@using MudBlazor

@inject IChatRepository ChatRepository
@inject AuthenticationStateProvider AuthStateProvider
@inject ChatStateService ChatState
@inject ChatHubClient ChatHubClient
@inject NotificationService Notifications

@implements IAsyncDisposable

<MudPaper Class="d-flex flex-column" Style="height:100%;overflow:hidden;" Elevation="0">
    <div class="flex-grow-1" style="overflow-y:auto;">
        <MudList T="ThreadSummary" Dense="true" Class="py-0">
            <Virtualize TItem="ThreadSummary"
                        @ref="_virt"
                        ItemsProvider="LoadThreads"
                        ItemSize="72"
                        OverscanCount="4">
                <ItemContent Context="t">
                    <MudListItem T="ThreadSummary"
                                 Class="px-3 py-2"
                                 Selected="@(t.Id == ChatState.ActiveThreadId)"
                                 OnClick="@(() => SelectThread(t))">
                        <div class="d-flex align-center">
                            <div class="mr-3">
                                <MudBadge Dot="true"
                                          Color="Color.Primary"
                                          Overlap="true"
                                          Bordered="true"
                                          Visible="@(t.Id != null && Notifications.GetThreadUnread(t.Id) > 0)">
                                    <MudAvatar Size="Size.Large">
                                        @if (!string.IsNullOrWhiteSpace(t.AvatarUrl))
                                        {
                                            <MudImage Src="@t.AvatarUrl" />
                                        }
                                        else
                                        {
                                            @Initials(DisplayTitle(t))
                                        }
                                    </MudAvatar>
                                </MudBadge>
                            </div>
                            <div class="flex-grow-1" style="min-width:0;">
                                <MudText Class="text-ellipsis">@DisplayTitle(t)</MudText>
                                <MudText Typo="Typo.caption" Class="@(GetPreviewClass(t))">
                                    @(!string.IsNullOrWhiteSpace(t.LastMessagePreview) ? t.LastMessagePreview : "Tap to start chat")
                                </MudText>
                            </div>
                        </div>
                    </MudListItem>
                </ItemContent>
            </Virtualize>
        </MudList>
    </div>
</MudPaper>

@if (_providerRan && _lastCount == 0)
{
    <div class="pa-3">
        <MudText Typo="Typo.caption" Class="mud-text-secondary">No conversations found.</MudText>
    </div>
}

@code {
    [Parameter] public EventCallback<ThreadSummary> OnThreadSelected { get; set; }
    [Parameter] public string SearchQuery { get; set; } = string.Empty;

    private string? _currentUserId;
    private Virtualize<ThreadSummary>? _virt;
    private bool _providerRan;
    private int _lastCount;
    private bool _autoSelected;
    private bool _refreshScheduled;
    private string _previousSearchQuery = string.Empty;

    private IReadOnlyList<ThreadSummary> _cacheItems = Array.Empty<ThreadSummary>();
    private int _cacheTotal = 0;

    private Func<Task>? _threadsUpdatedHandler;
    private Func<object, Task>? _threadReadHandler;
    private Action? _notificationsChangedHandler;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        _currentUserId = authState.User.FindFirstValue(ClaimTypes.NameIdentifier);

        _threadsUpdatedHandler = OnThreadsUpdated;
        ChatHubClient.ThreadsUpdated += _threadsUpdatedHandler;

        _threadReadHandler = OnThreadRead;
        ChatHubClient.ThreadRead += _threadReadHandler;

        _notificationsChangedHandler = OnNotificationsChanged;
        Notifications.Changed += _notificationsChangedHandler;
        await Notifications.InitializeAsync();

        await ChatHubClient.ConnectAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (SearchQuery != _previousSearchQuery)
        {
            _previousSearchQuery = SearchQuery;
            await Refresh();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _virt != null)
            await _virt.RefreshDataAsync();
    }

    private Task Refresh()
    {
        if (_refreshScheduled) return Task.CompletedTask;
        _refreshScheduled = true;

        _ = InvokeAsync(async () =>
        {
            await Task.Delay(50);
            _refreshScheduled = false;
            if (_virt != null) await _virt.RefreshDataAsync();
            StateHasChanged();
        });

        return Task.CompletedTask;
    }

    private Task OnThreadsUpdated() => Refresh();
    private Task OnThreadRead(object _) => Refresh();
    private void OnNotificationsChanged() => InvokeAsync(StateHasChanged);

    private async Task SelectThread(ThreadSummary t)
    {
        if (!string.IsNullOrEmpty(t.Id))
            Notifications.ClearThread(t.Id);

        ChatState.ActivateThread(t.Id!);
        await OnThreadSelected.InvokeAsync(t);
    }

    private async ValueTask<ItemsProviderResult<ThreadSummary>> LoadThreads(ItemsProviderRequest request)
    {
        _providerRan = true;

        if (string.IsNullOrEmpty(_currentUserId))
            return new ItemsProviderResult<ThreadSummary>(Array.Empty<ThreadSummary>(), 0);

        try
        {
            var (items, total) = await ChatRepository.GetThreadSummariesAsync(
                _currentUserId, SearchQuery, request.StartIndex, request.Count, request.CancellationToken);

            _lastCount = total;
            _cacheItems = items;
            _cacheTotal = total;

            if (!_autoSelected && string.IsNullOrEmpty(ChatState.ActiveThreadId) && total > 0 && items.Count > 0)
            {
                _autoSelected = true;
                var first = items[0];
                ChatState.ActivateThread(first.Id!);
                _ = OnThreadSelected.InvokeAsync(first);
            }

            return new ItemsProviderResult<ThreadSummary>(items, total);
        }
        catch (OperationCanceledException)
        {
            return new ItemsProviderResult<ThreadSummary>(_cacheItems, _cacheTotal);
        }
    }

    private static string DisplayTitle(ThreadSummary t)
    {
        var full = $"{t.FirstName} {t.LastName}".Trim();
        return string.IsNullOrWhiteSpace(full)
            ? (string.IsNullOrWhiteSpace(t.Title) ? "Conversation" : t.Title!)
            : full;
    }

    private static string Initials(string? name)
    {
        if (string.IsNullOrWhiteSpace(name)) return "?";
        var parts = name.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        return parts.Length == 1
            ? parts[0].Substring(0, 1).ToUpperInvariant()
            : $"{parts[0][0]}{parts[^1][0]}".ToUpperInvariant();
    }

    private static string GetPreviewClass(ThreadSummary t)
        => t.UnreadCount > 0
            ? "preview text-ellipsis mud-font-weight-semibold"
            : "preview text-ellipsis mud-text-secondary";

    public ValueTask DisposeAsync()
    {
        if (_threadsUpdatedHandler != null) ChatHubClient.ThreadsUpdated -= _threadsUpdatedHandler;
        if (_threadReadHandler != null) ChatHubClient.ThreadRead -= _threadReadHandler;
        if (_notificationsChangedHandler != null) Notifications.Changed -= _notificationsChangedHandler;
        return ValueTask.CompletedTask;
    }
}