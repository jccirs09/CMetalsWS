@using CMetalsWS.Data.Chat
@using MudBlazor

<div class="d-flex flex-row my-2 message-bubble @(IsMine ? "mine" : "theirs")">
    @if (!IsMine)
    {
        <MudAvatar Size="Size.Medium" Class="mr-2">@GetInitials(Message?.SenderName)</MudAvatar>
    }
    <div class="d-flex flex-column">
        <MudPaper Elevation="2" Class="pa-2 rounded-lg">
            @if (!IsMine)
            {
                <MudText Typo="Typo.caption" Class="font-weight-bold">@Message?.SenderName</MudText>
            }
            @if (_isEditing)
            {
                <MudTextField T="string" Value="@_editedContent" ValueChanged="@((s) => _editedContent = s)" OnKeyDown="OnEditKeyDown" />
            }
            else
            {
                <MudText>@Message?.Content</MudText>
            }
            <div class="d-flex align-center justify-end mt-1">
                @if (Message?.EditedAt != null)
                {
                    <MudText Typo="Typo.caption" Class="mr-1">(edited)</MudText>
                }
                <MudText Typo="Typo.caption" Class="mr-1">@Message?.CreatedAt.ToLocalTime().ToString("h:mm tt")</MudText>
                @if (IsMine)
                {
                    <MudIcon Icon="@GetReadReceiptIcon()" Size="Size.Small" Style="@GetReadReceiptColor()" />
                }
            </div>
        </MudPaper>
    <div class="reaction-bar mt-1">
        @if (Message?.Reactions.Any() == true)
        {
            @foreach (var reaction in Message.Reactions)
            {
                <MudTooltip Text="@GetReactionUsernames(reaction.Key)">
                    <MudChip T="string" Size="Size.Small" OnClick="@(() => OnReactionClicked.InvokeAsync(reaction.Key))">
                        @reaction.Key @reaction.Value.Count
                    </MudChip>
                </MudTooltip>
            }
        }
    </div>
    </div>
<MudMenu Icon="@Icons.Material.Filled.MoreVert" Size="Size.Small" Dense="true" Class="message-actions">
        <MudMenuItem OnClick="@(() => OnReactionClicked.InvokeAsync("ğŸ‘"))">ğŸ‘</MudMenuItem>
        <MudMenuItem OnClick="@(() => OnReactionClicked.InvokeAsync("â¤ï¸"))">â¤ï¸</MudMenuItem>
        <MudMenuItem OnClick="@(() => OnReactionClicked.InvokeAsync("ğŸ˜‚"))">ğŸ˜‚</MudMenuItem>
        <MudMenuItem OnClick="@(() => OnReactionClicked.InvokeAsync("ğŸ˜®"))">ğŸ˜®</MudMenuItem>
        <MudMenuItem OnClick="@(() => OnReactionClicked.InvokeAsync("ğŸ˜¢"))">ğŸ˜¢</MudMenuItem>
        <MudMenuItem OnClick="@(() => OnReactionClicked.InvokeAsync("ğŸ˜¡"))">ğŸ˜¡</MudMenuItem>
        <MudMenuItem OnClick="OnEditClicked">Edit</MudMenuItem>
        <MudMenuItem OnClick="@(() => OnDeleteClicked.InvokeAsync())">Delete</MudMenuItem>
        <MudMenuItem OnClick="@(() => OnPinClicked.InvokeAsync())">@(Message?.IsPinned == true ? "Unpin" : "Pin")</MudMenuItem>
</MudMenu>
</div>

@code {
    [Parameter] public MessageDto? Message { get; set; }
    [Parameter] public bool IsMine { get; set; }
    [Parameter] public EventCallback<string> OnReactionClicked { get; set; }
    [Parameter] public EventCallback<string> OnFinishEditing { get; set; }
    [Parameter] public EventCallback OnDeleteClicked { get; set; }
    [Parameter] public EventCallback OnPinClicked { get; set; }

    private bool _isEditing;
    private string _editedContent = string.Empty;

    private void OnEditClicked()
    {
        _isEditing = true;
        _editedContent = Message?.Content ?? string.Empty;
    }

    private async Task OnEditKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await OnFinishEditing.InvokeAsync(_editedContent);
            _isEditing = false;
        }
        else if (e.Key == "Escape")
        {
            _isEditing = false;
        }
    }

    private string GetReadReceiptIcon()
    {
        if (Message == null) return Icons.Material.Filled.AccessTime;

        var seenByOthersCount = Message.SeenBy.Count(s => s.Key != Message.SenderId);

        if (seenByOthersCount > 0) return Icons.Material.Filled.DoneAll;
        // The spec implies a "delivered" state, but we only have sent and seen.
        // We'll use single check for "sent".
        return Icons.Material.Filled.Check;
    }

    private string GetReadReceiptColor()
    {
        if (Message == null) return "color: var(--mud-palette-action-disabled);";

        var seenByOthersCount = Message.SeenBy.Count(s => s.Key != Message.SenderId);

        return seenByOthersCount > 0 ? "color: var(--mud-palette-info);" : "color: var(--mud-palette-action-disabled);";
    }

    private string? GetInitials(string? name)
    {
        if (string.IsNullOrWhiteSpace(name)) return null;
        var parts = name.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length > 1)
        {
            return $"{parts[0][0]}{parts[1][0]}".ToUpper();
        }
        return $"{name[0]}".ToUpper();
    }

    private string GetReactionUsernames(string emoji)
    {
        if (Message?.Reactions.TryGetValue(emoji, out var userIds) != true)
        {
            return string.Empty;
        }

        var names = userIds
            .Select(id => Message.ReactionUsers.GetValueOrDefault(id, "A user"))
            .ToList();

        return string.Join(", ", names);
    }
}
