@using CMetalsWS.Data
@using CMetalsWS.Data.Chat
@using CMetalsWS.Services
@using CMetalsWS.Services.SignalR
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims
@using System.Timers
@using Microsoft.JSInterop

@inject IChatRepository ChatRepository
@inject ChatHubClient ChatHubClient
@inject AuthenticationStateProvider AuthStateProvider
@inject IJSRuntime JSRuntime
@inject IDialogService DialogService

@implements IAsyncDisposable

<div class="d-flex flex-column" style="height: 100%;">
    <MudPaper Elevation="2" Class="pa-2 d-flex align-center">
        <MudText Typo="Typo.h6">@_threadTitle</MudText>
        <MudSpacer />
        <MudIconButton Icon="@Icons.Material.Filled.Search" OnClick="() => _searchOpen = !_searchOpen" />
        <MudMenu Icon="@Icons.Material.Filled.MoreVert">
            <MudMenuItem>Mute</MudMenuItem>
            <MudMenuItem OnClick="PinThread">@(IsThreadPinned ? "Unpin" : "Pin")</MudMenuItem>
            <MudMenuItem OnClick="RequestNotificationPermission">Enable Notifications</MudMenuItem>
        </MudMenu>
    </MudPaper>
    @if(_searchOpen)
    {
        <MudTextField T="string" @bind-Value="_searchQuery" Placeholder="Search in conversation..." Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" Immediate="true" />
    }

    @if (PinnedMessage != null)
    {
        <MudPaper Elevation="1" Class="pa-2 d-flex align-center">
            <MudIcon Icon="@Icons.Material.Filled.PushPin" Class="mr-2" />
            <MudText Typo="Typo.body2" Class="flex-grow-1">@PinnedMessage.Content</MudText>
            <MudIconButton Icon="@Icons.Material.Filled.Close" Size="Size.Small" OnClick="() => HandlePinClicked(PinnedMessage.Id, true)" />
        </MudPaper>
    }

    <div id="@_scrollContainerId" class="flex-grow-1 overflow-y-auto">
        @if (!_allMessagesLoaded)
        {
            <div class="d-flex justify-center pa-2">
                <MudButton OnClick="LoadMoreMessages" Disabled="@_isLoadingMore">
                    @if (_isLoadingMore)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    }
                    else
                    {
                        <MudText>Load More</MudText>
                    }
                </MudButton>
            </div>
        }
        <MudVirtualize Items="@FilteredMessages.ToList()" Context="message">
            <MessageBubble Message="message"
                         IsMine="message.SenderId == _currentUserId"
                         OnFinishEditing="(newContent) => HandleFinishEditing(message.Id, newContent)"
                         OnReactionClicked="(emoji) => HandleReactionClicked(message.Id, emoji)"
                         OnDeleteClicked="() => HandleDeleteClicked(message.Id)"
                         OnPinClicked="() => HandlePinClicked(message.Id, message.IsPinned)" />
        </MudVirtualize>
    </div>

    <MudPaper Elevation="2" Class="pa-2">
        <div class="d-flex align-center">
            <MudIconButton Icon="@Icons.Material.Filled.TagFaces" />
            <MudTextField @ref="_textField"
                          @bind-Value="_newMessage"
                          Placeholder="Type a message..."
                          Class="flex-grow-1"
                          @oninput="OnNewMessageInput"
                          For="@(() => _newMessage)"
                          T="string"
                          id="@_messageInputId" />
            <MudIconButton Icon="@Icons.Material.Filled.Send" OnClick="SendMessage" Disabled="string.IsNullOrWhiteSpace(_newMessage)" />
        </div>
    </MudPaper>
    <MentionSuggest @ref="_mentionSuggest" Suggestions="_participants" OnUserSelected="OnUserMentioned" Filter="@_mentionFilter" />
</div>

@code {
    [Parameter] public string? ThreadId { get; set; }

    private string? _currentUserId;
    private string? _threadTitle;
    private List<MessageDto> _messages = new();
    private List<ApplicationUser> _participants = new();
    private bool _allMessagesLoaded;
    private bool IsThreadPinned { get; set; }
    private Timer? _typingTimer;

    private readonly string _scrollContainerId = $"scroll-container-{Guid.NewGuid()}";
    private readonly string _messageInputId = $"message-input-{Guid.NewGuid()}";
    private MudTextField<string>? _textField;
    private MentionSuggest? _mentionSuggest;
    private string _newMessage = string.Empty;
    private bool _shouldScrollToBottom = true;

    private bool _searchOpen;
    private string _searchQuery = string.Empty;
    private IEnumerable<MessageDto> FilteredMessages => string.IsNullOrWhiteSpace(_searchQuery) ? _messages : _messages.Where(m => m.Content?.Contains(_searchQuery, StringComparison.OrdinalIgnoreCase) ?? false);
    private MessageDto? PinnedMessage => _messages.FirstOrDefault(m => m.IsPinned);

    private bool _isLoadingMore;
    private int _mentionStartPosition;
    private string _mentionFilter = string.Empty;
    private bool _typingSent;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        _currentUserId = authState.User.FindFirstValue(ClaimTypes.NameIdentifier);

        await ChatHubClient.ConnectAsync();
        ChatHubClient.MessageReceived += OnMessageReceived;
        ChatHubClient.UserTyping += OnUserTyping;
        ChatHubClient.MessageUpdated += OnMessageUpdated;
        ChatHubClient.MessagePinned += OnMessagePinned;
        ChatHubClient.MessageDeleted += OnMessageDeleted;

        if (ThreadId != null)
        {
            await LoadThreadAsync(ThreadId);
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (ThreadId != null && !_messages.Any(m => m.ThreadId == ThreadId))
        {
            await LoadThreadAsync(ThreadId);
        }
    }

    private async Task LoadThreadAsync(string threadId)
    {
        var previous = _messages.FirstOrDefault()?.ThreadId;
        if (!string.IsNullOrEmpty(previous) && previous != threadId)
        {
            await ChatHubClient.LeaveThreadAsync(previous);
        }

        _messages.Clear();
        _participants.Clear();
        _allMessagesLoaded = false;

        await ChatHubClient.JoinThreadAsync(threadId);
        _participants = (await ChatRepository.GetThreadParticipantsAsync(threadId, _currentUserId!)).ToList();

        var summaries = await ChatRepository.GetThreadSummariesAsync(_currentUserId!);
        var summary = summaries.FirstOrDefault(s => s.Id == threadId);
        _threadTitle = summary?.Title ?? _participants.FirstOrDefault(p => p.Id != _currentUserId)?.UserName ?? "Chat";
        IsThreadPinned = summary?.IsPinned ?? false;

        var initial = (await ChatRepository.GetMessagesAsync(threadId, _currentUserId!)).ToList();
        _messages.AddRange(initial);
        _allMessagesLoaded = !initial.Any() || initial.Count < 50;

        _shouldScrollToBottom = true;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_shouldScrollToBottom)
        {
            await JSRuntime.InvokeVoidAsync("cmetalsChat.scrollToBottom", _scrollContainerId);
            _shouldScrollToBottom = false;
        }
    }

    private async Task LoadMoreMessages()
    {
        if (_isLoadingMore || _allMessagesLoaded || ThreadId == null || !_messages.Any()) return;

        _isLoadingMore = true;
        StateHasChanged();

        var oldestMessage = _messages.FirstOrDefault();
        if (oldestMessage == null)
        {
            _isLoadingMore = false;
            return;
        }

        var olderMessages = (await ChatRepository.GetMessagesAsync(ThreadId, _currentUserId!, oldestMessage.CreatedAt)).ToList();

        if (olderMessages.Any())
        {
            _messages.InsertRange(0, olderMessages);
        }
        else
        {
            _allMessagesLoaded = true;
        }

        _isLoadingMore = false;
        StateHasChanged();
    }

    private async Task OnMessageReceived(MessageDto message)
    {
        if (message.ThreadId == ThreadId)
        {
            var tempMessage = _messages.FirstOrDefault(m => m.Id == 0 && m.SenderId == message.SenderId && m.Content == message.Content);
            if (tempMessage != null)
            {
                tempMessage.Id = message.Id;
                tempMessage.CreatedAt = message.CreatedAt;
            }
            else
            {
                _messages.Add(message);
                if (message.SenderId != _currentUserId)
                {
                    var isFocused = await JSRuntime.InvokeAsync<bool>("cmetalsChat.isDocumentFocused");
                    if (!isFocused)
                    {
                        await JSRuntime.InvokeVoidAsync("cmetalsChat.playSound", "pop");
                        await JSRuntime.InvokeVoidAsync("cmetalsChat.showNotification", message.SenderName, message.Content);
                    }
                }
            }
            _shouldScrollToBottom = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task OnMessageUpdated(MessageDto message)
    {
        var messageToUpdate = _messages.FirstOrDefault(m => m.Id == message.Id);
        if (messageToUpdate != null)
        {
            messageToUpdate.Content = message.Content;
            messageToUpdate.EditedAt = message.EditedAt;
            messageToUpdate.Reactions = message.Reactions;
            messageToUpdate.ReactionUsers = message.ReactionUsers;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(_newMessage) || ThreadId == null) return;
        var tempMessage = new MessageDto { Id = 0, Content = _newMessage, CreatedAt = DateTime.UtcNow, SenderId = _currentUserId, SenderName = "Me", ThreadId = ThreadId };
        _messages.Add(tempMessage);
        var messageToSend = _newMessage;
        _newMessage = string.Empty;
        _shouldScrollToBottom = true;
        await InvokeAsync(StateHasChanged);
        await ChatHubClient.SendMessageAsync(ThreadId, messageToSend);
    }

    public async ValueTask DisposeAsync()
    {
        if (ThreadId != null)
        {
            await ChatHubClient.LeaveThreadAsync(ThreadId);
        }
        ChatHubClient.MessageReceived -= OnMessageReceived;
        ChatHubClient.UserTyping -= OnUserTyping;
        ChatHubClient.MessageUpdated -= OnMessageUpdated;
        ChatHubClient.MessagePinned -= OnMessagePinned;
        ChatHubClient.MessageDeleted -= OnMessageDeleted;
        _typingTimer?.Dispose();
    }

    private async Task PinThread()
    {
        if (ThreadId != null)
        {
            await ChatHubClient.PinThreadAsync(ThreadId, !IsThreadPinned);
            IsThreadPinned = !IsThreadPinned;
        }
    }

    private async Task RequestNotificationPermission() => await JSRuntime.InvokeAsync<string>("cmetalsChat.requestNotificationPermission");

    private async Task OnUserTyping(TypingDto typingInfo)
    {
        if (typingInfo.ThreadId == ThreadId && typingInfo.UserId != _currentUserId)
        {
            // Simplified logic: just add/remove user ID. A better implementation might use a dictionary with timers.
            if (typingInfo.IsTyping && !_participants.Any(p => p.Id == typingInfo.UserId))
            {
                // This part is tricky as we don't have the user name. For now, we'll ignore showing the name.
            }
        }
    }

    private async Task OnNewMessageInput(ChangeEventArgs e)
    {
        _newMessage = e.Value?.ToString() ?? string.Empty;
        await Task.Delay(1);
        var cursorPosition = await JSRuntime.InvokeAsync<int>("cmetalsChat.getCursorPosition", _messageInputId);
        var textBeforeCursor = _newMessage.Substring(0, cursorPosition);
        var lastAt = textBeforeCursor.LastIndexOf('@');
        var lastSpace = textBeforeCursor.LastIndexOf(' ');
        if (lastAt != -1 && lastAt > lastSpace)
        {
            _mentionStartPosition = lastAt;
            _mentionFilter = textBeforeCursor.Substring(lastAt + 1);
            _mentionSuggest?.Open();
        }
        else
        {
            _mentionSuggest?.Close();
        }
        if (ThreadId == null) return;
        if (_typingTimer == null)
        {
            _typingTimer = new Timer(1500);
            _typingTimer.Elapsed += async (sender, args) => {
                if(ThreadId != null) await ChatHubClient.TypingAsync(ThreadId, false);
                _typingSent = false;
                _typingTimer.Stop();
            };
            _typingTimer.AutoReset = false;
        }
        if (!_typingSent)
        {
            _typingSent = true;
            if(ThreadId != null) await ChatHubClient.TypingAsync(ThreadId, true);
        }
        _typingTimer.Stop();
        _typingTimer.Start();
    }

    private void OnUserMentioned(ApplicationUser user)
    {
        var before = _newMessage.Substring(0, _mentionStartPosition);
        var after = _newMessage.Substring(_mentionStartPosition + _mentionFilter.Length + 1);
        _newMessage = $"{before}@{user.UserName} {after}";
        _mentionSuggest?.Close();
    }

    private async Task HandleFinishEditing(int messageId, string newContent) => await ChatHubClient.UpdateMessageAsync(messageId, newContent);

    private async Task HandlePinClicked(int messageId, bool isCurrentlyPinned) => await ChatHubClient.PinMessageAsync(messageId, !isCurrentlyPinned);

    private async Task HandleReactionClicked(int messageId, string emoji)
    {
        var message = _messages.FirstOrDefault(m => m.Id == messageId);
        if (message != null)
        {
            if (message.Reactions.TryGetValue(emoji, out var users) && users.Contains(_currentUserId!))
                await ChatHubClient.RemoveReactionAsync(messageId, emoji);
            else
                await ChatHubClient.AddReactionAsync(messageId, emoji);
        }
    }

    private async Task HandleDeleteClicked(int messageId)
    {
        var parameters = new DialogParameters { ["Title"] = "Delete Message", ["ContentText"] = "Are you sure you want to delete this message? This cannot be undone.", ["SubmitText"] = "Delete", ["CancelText"] = "Cancel" };
        var dialog = DialogService.Show<MudMessageBox>("Delete Message", parameters);
        var result = await dialog.Result;
        if (!result.Canceled)
            await ChatHubClient.DeleteMessageAsync(messageId);
    }

    private async Task OnMessagePinned(MessageDto message)
    {
        var oldPinned = _messages.FirstOrDefault(m => m.IsPinned);
        if (oldPinned != null) oldPinned.IsPinned = false;
        var newPinned = _messages.FirstOrDefault(m => m.Id == message.Id);
        if (newPinned != null) newPinned.IsPinned = message.IsPinned;
        await InvokeAsync(StateHasChanged);
    }

    private async Task OnMessageDeleted(int messageId)
    {
        _messages.RemoveAll(m => m.Id == messageId);
        await InvokeAsync(StateHasChanged);
    }
}
