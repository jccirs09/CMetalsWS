@using CMetalsWS.Data
@using CMetalsWS.Data.Chat
@using CMetalsWS.Services
@using CMetalsWS.Services.SignalR
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims
@using System.Timers
@using Microsoft.JSInterop
@using MudBlazor

@inject IChatRepository ChatRepository
@inject ChatHubClient ChatHubClient
@inject AuthenticationStateProvider AuthStateProvider
@inject IJSRuntime JSRuntime
@inject IDialogService DialogService
@inject NotificationService Notifications

@implements IAsyncDisposable

<div class="d-flex flex-column" style="height: 100%;">
    <MudPaper Elevation="1" Class="pa-3 d-flex align-center">
        <MudText Typo="Typo.h6">@_threadTitle</MudText>
    </MudPaper>

    <div id="@_scrollContainerId" class="flex-grow-1 overflow-y-auto pa-3">
        @if (!_allMessagesLoaded)
        {
            <div class="d-flex justify-center pa-2">
                <MudButton OnClick="LoadMoreMessages" Disabled="@_isLoadingMore">
                    @if (_isLoadingMore)
                    {
                        <MudProgressCircular Size="Size.Small" Indeterminate="true" />
                    }
                    else
                    {
                        <MudText>Load More</MudText>
                    }
                </MudButton>
            </div>
        }
        <div class="d-flex flex-column" style="gap: 0.75rem;">
            <MudVirtualize Items="@_messages.ToList()" Context="message">
                <MessageBubble Message="message"
                         IsMine="message.SenderId == _currentUserId"
                         OnFinishEditing="(newContent) => HandleFinishEditing(message.Id, newContent)"
                         OnReactionClicked="(emoji) => HandleReactionClicked(message.Id, emoji)"
                         OnDeleteClicked="() => HandleDeleteClicked(message.Id)"
                         OnPinClicked="() => HandlePinClicked(message.Id, message.IsPinned)" />
            </MudVirtualize>
        </div>
    </div>

    <div class="typing-indicator-container px-3" style="height: 24px;">
        @if(_isSomeoneTyping)
        {
            <MudText Typo="Typo.caption" Class="mud-text-secondary"><i>@_typingUser is typing...</i></MudText>
        }
    </div>

    <MudPaper Elevation="2" Class="pa-2">
        <div class="d-flex align-center">
            <MudTextField @ref="_textField"
                          @bind-Value="_newMessage"
                          Placeholder="Type a message..."
                          Class="flex-grow-1"
                          Variant="Variant.Outlined"
                          Margin="Margin.Dense"
                          HideDetails="true"
                          @oninput="OnNewMessageInput"
                          @onkeydown="HandleKeyDown"
                          T="string"
                          id="@_messageInputId" />
            <MudIconButton Icon="@Icons.Material.Filled.Send" OnClick="SendMessage" Disabled="string.IsNullOrWhiteSpace(_newMessage)" Class="ml-2"/>
        </div>
    </MudPaper>
    <MentionSuggest @ref="_mentionSuggest" Suggestions="_participants" OnUserSelected="OnUserMentioned" Filter="@_mentionFilter" />
</div>

@code {
    [Parameter] public string? ThreadId { get; set; }

    private string? _currentUserId;
    private string? _threadTitle;
    private string? _lastThreadId;
    private List<MessageDto> _messages = new();
    private List<ApplicationUser> _participants = new();
    private bool _allMessagesLoaded;
    private Timer? _typingTimer;

    private readonly string _scrollContainerId = $"scroll-container-{Guid.NewGuid()}";
    private readonly string _messageInputId = $"message-input-{Guid.NewGuid()}";
    private MudTextField<string>? _textField;
    private MentionSuggest? _mentionSuggest;
    private string _newMessage = string.Empty;
    private bool _shouldScrollToBottom = true;

    private bool _isLoadingMore;
    private int _mentionStartPosition;
    private string _mentionFilter = string.Empty;
    private bool _typingSent;
    private CancellationTokenSource? _loadCts;
    private bool _isInitialized = false;

    private bool _isSomeoneTyping;
    private string _typingUser = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        _currentUserId = authState.User.FindFirstValue(ClaimTypes.NameIdentifier);

        ChatHubClient.MessageReceived += OnMessageReceived;
        ChatHubClient.UserTyping += OnUserTyping;
        ChatHubClient.MessageUpdated += OnMessageUpdated;
        ChatHubClient.MessagePinned += OnMessagePinned;
        ChatHubClient.MessageDeleted += OnMessageDeleted;
    }

    protected override async Task OnParametersSetAsync()
    {
        if (string.IsNullOrWhiteSpace(ThreadId) || ThreadId == _lastThreadId)
            return;

        var newId = ThreadId;
        _lastThreadId = newId;

        Notifications.ClearThread(newId);
        _ = ChatHubClient.MarkReadAsync(newId);

        await LoadThreadAsync(newId);
    }

    private async Task LoadThreadAsync(string threadId)
    {
        _loadCts?.Cancel();
        _loadCts = new CancellationTokenSource();

        var previous = _messages.FirstOrDefault()?.ThreadId;
        if (!string.IsNullOrEmpty(previous) && previous != threadId)
        {
            await ChatHubClient.LeaveThreadAsync(previous);
        }

        _messages.Clear();
        _participants.Clear();
        _allMessagesLoaded = false;

        await ChatHubClient.JoinThreadAsync(threadId);
        _participants = (await ChatRepository.GetThreadParticipantsAsync(threadId, _currentUserId!)).ToList();

        var summaries = await ChatRepository.GetThreadSummariesAsync(_currentUserId!);
        var summary = summaries.FirstOrDefault(s => s.Id == threadId);
        _threadTitle = summary?.Title ?? _participants.FirstOrDefault(p => p.Id != _currentUserId)?.UserName ?? "Chat";

        var initial = (await ChatRepository.GetMessagesAsync(threadId, _currentUserId!)).ToList();
        _messages.AddRange(initial);
        _allMessagesLoaded = !initial.Any() || initial.Count < 50;

        _shouldScrollToBottom = true;
        StateHasChanged();
        await ChatHubClient.MarkReadAsync(threadId);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_isInitialized)
        {
            _isInitialized = true;
            await ChatHubClient.ConnectAsync();
            if (ThreadId != null)
            {
                await LoadThreadAsync(ThreadId);
            }
        }

        if (_shouldScrollToBottom)
        {
            await JSRuntime.InvokeVoidAsync("cmetalsChat.scrollToBottom", _scrollContainerId);
            _shouldScrollToBottom = false;
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }

    private async Task LoadMoreMessages()
    {
        if (_isLoadingMore || _allMessagesLoaded || ThreadId == null || !_messages.Any()) return;
        _isLoadingMore = true;
        StateHasChanged();

        var oldestMessage = _messages.FirstOrDefault();
        if (oldestMessage == null) { _isLoadingMore = false; return; }

        var olderMessages = (await ChatRepository.GetMessagesAsync(ThreadId, _currentUserId!, oldestMessage.CreatedAt)).ToList();
        if (olderMessages.Any()) { _messages.InsertRange(0, olderMessages); }
        else { _allMessagesLoaded = true; }

        _isLoadingMore = false;
        StateHasChanged();
    }

    private async Task OnMessageReceived(MessageDto message)
    {
        if (message.ThreadId == ThreadId || (message.SenderId == ThreadId && message.ThreadId == _currentUserId))
        {
            var tempMessage = _messages.FirstOrDefault(m => m.Id == 0 && m.SenderId == message.SenderId && m.Content == message.Content);
            if (tempMessage != null)
            {
                tempMessage.Id = message.Id;
                tempMessage.CreatedAt = message.CreatedAt;
            }
            else
            {
                _messages.Add(message);
            }
            _shouldScrollToBottom = true;
            await InvokeAsync(StateHasChanged);
            await ChatHubClient.MarkReadAsync(ThreadId!);
        }
    }

    private async Task OnMessageUpdated(MessageDto message)
    {
        var msg = _messages.FirstOrDefault(m => m.Id == message.Id);
        if (msg != null)
        {
            msg.Content = message.Content;
            msg.EditedAt = message.EditedAt;
            msg.Reactions = message.Reactions;
            msg.ReactionUsers = message.ReactionUsers;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(_newMessage) || ThreadId == null) return;
        var tempMessage = new MessageDto { Id = 0, Content = _newMessage, CreatedAt = DateTime.UtcNow, SenderId = _currentUserId, SenderName = "Me", ThreadId = ThreadId };
        _messages.Add(tempMessage);
        var messageToSend = _newMessage;
        _newMessage = string.Empty;
        _shouldScrollToBottom = true;
        await InvokeAsync(StateHasChanged);
        await ChatHubClient.SendMessageAsync(ThreadId, messageToSend);
    }

    public async ValueTask DisposeAsync()
    {
        if (ThreadId != null) await ChatHubClient.LeaveThreadAsync(ThreadId);
        ChatHubClient.MessageReceived -= OnMessageReceived;
        ChatHubClient.UserTyping -= OnUserTyping;
        ChatHubClient.MessageUpdated -= OnMessageUpdated;
        ChatHubClient.MessagePinned -= OnMessagePinned;
        ChatHubClient.MessageDeleted -= OnMessageDeleted;
        _typingTimer?.Dispose();
    }

    private async Task OnUserTyping(TypingDto typingInfo)
    {
        if (typingInfo.ThreadId == ThreadId && typingInfo.UserId != _currentUserId)
        {
            if (typingInfo.IsTyping)
            {
                var user = _participants.FirstOrDefault(p => p.Id == typingInfo.UserId);
                _typingUser = user?.UserName ?? "Someone";
                _isSomeoneTyping = true;
            }
            else
            {
                _isSomeoneTyping = false;
            }
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task OnNewMessageInput(ChangeEventArgs e)
    {
        _newMessage = e.Value?.ToString() ?? string.Empty;
        await Task.Delay(1);
        var cursorPosition = await JSRuntime.InvokeAsync<int>("cmetalsChat.getCursorPosition", _messageInputId);
        var textBeforeCursor = _newMessage.Substring(0, cursorPosition);
        var lastAt = textBeforeCursor.LastIndexOf('@');
        var lastSpace = textBeforeCursor.LastIndexOf(' ');
        if (lastAt != -1 && lastAt > lastSpace)
        {
            _mentionStartPosition = lastAt;
            _mentionFilter = textBeforeCursor.Substring(lastAt + 1);
            _mentionSuggest?.Open();
        }
        else
        {
            _mentionSuggest?.Close();
        }
        if (ThreadId == null) return;
        if (_typingTimer == null)
        {
            _typingTimer = new Timer(1500);
            _typingTimer.Elapsed += async (sender, args) => {
                if(ThreadId != null) await ChatHubClient.TypingAsync(ThreadId, false);
                _typingSent = false;
                _typingTimer.Stop();
            };
            _typingTimer.AutoReset = false;
        }
        if (!_typingSent)
        {
            _typingSent = true;
            if(ThreadId != null) await ChatHubClient.TypingAsync(ThreadId, true);
        }
        _typingTimer.Stop();
        _typingTimer.Start();
    }

    private async void OnUserMentioned(ApplicationUser user)
    {
        var before = _newMessage.Substring(0, _mentionStartPosition);
        var after = _newMessage.Substring(_mentionStartPosition + _mentionFilter.Length + 1);
        _newMessage = $"{before}@{user.UserName} {after}";
        _mentionSuggest?.Close();
        await _textField.FocusAsync();
    }

    private async Task HandleFinishEditing(int messageId, string newContent) => await ChatHubClient.UpdateMessageAsync(messageId, newContent);
    private async Task HandlePinClicked(int messageId, bool isCurrentlyPinned) => await ChatHubClient.PinMessageAsync(messageId, !isCurrentlyPinned);

    private async Task HandleReactionClicked(int messageId, string emoji)
    {
        var message = _messages.FirstOrDefault(m => m.Id == messageId);
        if (message != null && !string.IsNullOrEmpty(_currentUserId))
        {
            if (message.Reactions.TryGetValue(emoji, out var users) && users.Contains(_currentUserId))
                await ChatHubClient.RemoveReactionAsync(messageId, emoji);
            else
                await ChatHubClient.AddReactionAsync(messageId, emoji);
        }
    }

    private async Task HandleDeleteClicked(int messageId)
    {
        var result = await DialogService.ShowMessageBox("Delete Message", "Are you sure you want to delete this message? This cannot be undone.", yesText: "Delete", cancelText: "Cancel");
        if (result == true) await ChatHubClient.DeleteMessageAsync(messageId);
    }
    private async Task OnMessagePinned(MessageDto message)
    {
        var msg = _messages.FirstOrDefault(m => m.Id == message.Id);
        if(msg != null)
        {
            msg.IsPinned = message.IsPinned;
            await InvokeAsync(StateHasChanged);
        }
    }
    private async Task OnMessageDeleted(int messageId)
    {
        _messages.RemoveAll(m => m.Id == messageId);
        await InvokeAsync(StateHasChanged);
    }
}