@using CMetalsWS.Data
@using CMetalsWS.Data.Chat
@using CMetalsWS.Services
@using CMetalsWS.Services.SignalR
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims
@using System.Timers
@using Microsoft.JSInterop

@inject IChatRepository ChatRepository
@inject ChatHubClient ChatHubClient
@inject AuthenticationStateProvider AuthStateProvider
@inject IJSRuntime JSRuntime
@inject IDialogService DialogService

@implements IAsyncDisposable

<MudPaper Outlined="true" Class="d-flex flex-column mud-height-full">
    <MudToolBar Dense="true">
        <MudText Typo="Typo.h6">@_threadTitle</MudText>
        <MudSpacer />
        <MudIconButton Icon="@Icons.Material.Filled.Search" OnClick="() => _searchOpen = !_searchOpen" />
        <MudMenu Icon="@Icons.Material.Filled.MoreVert">
            <MudMenuItem>Mute</MudMenuItem>
            <MudMenuItem OnClick="PinThread">@(IsThreadPinned ? "Unpin" : "Pin")</MudMenuItem>
            <MudMenuItem OnClick="RequestNotificationPermission">Enable Notifications</MudMenuItem>
        </MudMenu>
    </MudToolBar>

    <div class="flex-grow-1 overflow-y-auto" id="@_scrollContainerId">
        @if(_searchOpen)
        {
            <MudTextField T="string" @bind-Value="_searchQuery" Placeholder="Search in conversation..." Adornment="Adornment.Start" AdornmentIcon="@Icons.Material.Filled.Search" Immediate="true" Class="mx-4 my-2" />
        }
        @if (PinnedMessage != null)
        {
            <MudPaper Elevation="1" Class="pa-2 d-flex align-center mx-4 my-2">
                <MudIcon Icon="@Icons.Material.Filled.PushPin" Class="mr-2" />
                <MudText Typo="Typo.body2" Class="flex-grow-1">@PinnedMessage.Content</MudText>
                <MudIconButton Icon="@Icons.Material.Filled.Close" Size="Size.Small" OnClick="() => HandlePinClicked(PinnedMessage.Id, true)" />
            </MudPaper>
        }
        @if (!_allMessagesLoaded)
        {
            <div class="d-flex justify-center pa-2">
                <MudButton OnClick="LoadMoreMessages" Disabled="@_isLoadingMore">
                    @if (_isLoadingMore) { <MudProgressCircular Size="Size.Small" Indeterminate="true" /> }
                    else { <MudText>Load More</MudText> }
                </MudButton>
            </div>
        }
        <div class="pa-4 mud-chat-container">
            @foreach (var group in GroupedMessages)
            {
                <MudChat ChatPosition="@(group.SenderId == _currentUserId ? ChatBubblePosition.End : ChatBubblePosition.Start)">
                    <ChatAvatar>
                        <MudAvatar Size="Size.Small">
                            @if (!string.IsNullOrWhiteSpace(group.AvatarUrl))
                            {
                                <MudImage Src="@group.AvatarUrl" />
                            }
                            else
                            {
                                <span class="mud-typography-h6">@GetInitials(group.SenderName)</span>
                            }
                        </MudAvatar>
                    </ChatAvatar>
                    <ChatMessages>
                        @for (var i = 0; i < group.Messages.Count; i++)
                        {
                            var message = group.Messages[i];
                            var showName = i == 0;
                            <MessageBubble Message="message"
                                         IsMine="group.SenderId == _currentUserId"
                                         ShowSenderName="showName"
                                         OnFinishEditing="(newContent) => HandleFinishEditing(message.Id, newContent)"
                                         OnReactionClicked="(emoji) => HandleReactionClicked(message.Id, emoji)"
                                         OnDeleteClicked="() => HandleDeleteClicked(message.Id)"
                                         OnPinClicked="() => HandlePinClicked(message.Id, message.IsPinned)" />
                        }
                    </ChatMessages>
                </MudChat>
            }
        </div>
    </div>

    <MudPaper Elevation="2" Class="pa-2">
        <div class="d-flex align-center">
            <MudIconButton Icon="@Icons.Material.Filled.TagFaces" />
            <MudTextField @ref="_textField"
                          @bind-Value="_newMessage"
                          Placeholder="Type a message..."
                          Class="flex-grow-1"
                          @oninput="OnNewMessageInput"
                          For="@(() => _newMessage)"
                          T="string"
                          id="@_messageInputId" />
            <MudIconButton Icon="@Icons.Material.Filled.Send" OnClick="SendMessage" Disabled="string.IsNullOrWhiteSpace(_newMessage)" />
        </div>
    </MudPaper>
    <MentionSuggest @ref="_mentionSuggest" Suggestions="_participants" OnUserSelected="OnUserMentioned" Filter="@_mentionFilter" />
</MudPaper>

@code {
    public class MessageGroup
    {
        public string? SenderId { get; set; }
        public string? SenderName { get; set; }
        public string? AvatarUrl { get; set; }
        public List<MessageDto> Messages { get; set; } = new();
    }

    private IEnumerable<MessageGroup> GroupedMessages
    {
        get
        {
            var groups = new List<MessageGroup>();
            if (FilteredMessages == null || !FilteredMessages.Any())
                return groups;

            MessageGroup? currentGroup = null;
            foreach (var message in FilteredMessages)
            {
                if (currentGroup == null || currentGroup.SenderId != message.SenderId)
                {
                    currentGroup = new MessageGroup
                    {
                        SenderId = message.SenderId,
                        SenderName = message.SenderName,
                        AvatarUrl = _participants.FirstOrDefault(p => p.Id == message.SenderId)?.Avatar
                    };
                    groups.Add(currentGroup);
                }
                currentGroup.Messages.Add(message);
            }
            return groups;
        }
    }

    [Parameter] public string? ThreadId { get; set; }

    private string? _currentUserId;
    private string? _threadTitle;
    private List<MessageDto> _messages = new();
    private List<ApplicationUser> _participants = new();
    private bool _allMessagesLoaded;
    private bool IsThreadPinned { get; set; }
    private Timer? _typingTimer;

    private readonly string _scrollContainerId = $"scroll-container-{Guid.NewGuid()}";
    private readonly string _messageInputId = $"message-input-{Guid.NewGuid()}";
    private MudTextField<string>? _textField;
    private MentionSuggest? _mentionSuggest;
    private string _newMessage = string.Empty;
    private bool _shouldScrollToBottom = true;

    private bool _searchOpen;
    private string _searchQuery = string.Empty;
    private IEnumerable<MessageDto> FilteredMessages => string.IsNullOrWhiteSpace(_searchQuery) ? _messages : _messages.Where(m => m.Content?.Contains(_searchQuery, StringComparison.OrdinalIgnoreCase) ?? false);
    private MessageDto? PinnedMessage => _messages.FirstOrDefault(m => m.IsPinned);

    private bool _isLoadingMore;
    private int _mentionStartPosition;
    private string _mentionFilter = string.Empty;
    private bool _typingSent;

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        _currentUserId = authState.User.FindFirstValue(ClaimTypes.NameIdentifier);

        ChatHubClient.MessageReceived += OnMessageReceived;
        ChatHubClient.UserTyping += OnUserTyping;
        ChatHubClient.MessageUpdated += OnMessageUpdated;
        ChatHubClient.MessagePinned += OnMessagePinned;
        ChatHubClient.MessageDeleted += OnMessageDeleted;

        if (ThreadId != null)
        {
            await LoadThreadAsync(ThreadId);
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (ThreadId != null && !_messages.Any(m => m.ThreadId == ThreadId))
        {
            await LoadThreadAsync(ThreadId);
        }
    }

    private async Task LoadThreadAsync(string threadId)
    {
        var previous = _messages.FirstOrDefault()?.ThreadId;
        if (!string.IsNullOrEmpty(previous) && previous != threadId)
        {
            await ChatHubClient.LeaveThreadAsync(previous);
        }

        _messages.Clear();
        _participants.Clear();
        _allMessagesLoaded = false;

        await ChatHubClient.JoinThreadAsync(threadId);
        _participants = (await ChatRepository.GetThreadParticipantsAsync(threadId, _currentUserId!)).ToList();

        var summaries = await ChatRepository.GetThreadSummariesAsync(_currentUserId!);
        var summary = summaries.FirstOrDefault(s => s.Id == threadId);
        _threadTitle = summary?.Title ?? _participants.FirstOrDefault(p => p.Id != _currentUserId)?.UserName ?? "Chat";
        IsThreadPinned = summary?.IsPinned ?? false;

        var initial = (await ChatRepository.GetMessagesAsync(threadId, _currentUserId!)).ToList();
        _messages.AddRange(initial);
        _allMessagesLoaded = !initial.Any() || initial.Count < 50;

        _shouldScrollToBottom = true;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await ChatHubClient.ConnectAsync();
        }

        if (_shouldScrollToBottom)
        {
            await JSRuntime.InvokeVoidAsync("cmetalsChat.scrollToBottom", _scrollContainerId);
            _shouldScrollToBottom = false;
        }
    }

    private async Task LoadMoreMessages()
    {
        if (_isLoadingMore || _allMessagesLoaded || ThreadId == null || !_messages.Any()) return;
        _isLoadingMore = true;
        StateHasChanged();
        var oldestMessage = _messages.FirstOrDefault();
        if (oldestMessage == null) { _isLoadingMore = false; return; }
        var olderMessages = (await ChatRepository.GetMessagesAsync(ThreadId, _currentUserId!, oldestMessage.CreatedAt)).ToList();
        if (olderMessages.Any()) _messages.InsertRange(0, olderMessages);
        else _allMessagesLoaded = true;
        _isLoadingMore = false;
        StateHasChanged();
    }

    private async Task OnMessageReceived(MessageDto message)
    {
        bool isRelevant = false;
        if (message.ThreadId != null && message.ThreadId.StartsWith("g:"))
        {
            isRelevant = message.ThreadId == ThreadId;
        }
        else
        {
            var conversationParticipants = new HashSet<string?> { _currentUserId, ThreadId };
            var messageParticipants = new HashSet<string?> { message.SenderId, message.ThreadId };
            isRelevant = conversationParticipants.SetEquals(messageParticipants);
        }

        if (isRelevant)
        {
            var tempMessage = _messages.FirstOrDefault(m => m.Id == 0 && m.SenderId == message.SenderId && m.Content == message.Content);
            if (tempMessage != null)
            {
                tempMessage.Id = message.Id;
                tempMessage.CreatedAt = message.CreatedAt;
            }
            else
            {
                _messages.Add(message);
                if (message.SenderId != _currentUserId)
                {
                    var isFocused = await JSRuntime.InvokeAsync<bool>("cmetalsChat.isDocumentFocused");
                    if (!isFocused)
                    {
                        await JSRuntime.InvokeVoidAsync("cmetalsChat.playSound", "pop");
                        await JSRuntime.InvokeVoidAsync("cmetalsChat.showNotification", message.SenderName, message.Content);
                    }
                }
            }
            _shouldScrollToBottom = true;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task OnMessageUpdated(MessageDto message)
    {
        var messageToUpdate = _messages.FirstOrDefault(m => m.Id == message.Id);
        if (messageToUpdate != null)
        {
            messageToUpdate.Content = message.Content;
            messageToUpdate.EditedAt = message.EditedAt;
            messageToUpdate.Reactions = message.Reactions;
            messageToUpdate.ReactionUsers = message.ReactionUsers;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(_newMessage) || ThreadId == null) return;
        var tempMessage = new MessageDto { Id = 0, Content = _newMessage, CreatedAt = DateTime.UtcNow, SenderId = _currentUserId, SenderName = "Me", ThreadId = ThreadId };
        _messages.Add(tempMessage);
        var messageToSend = _newMessage;
        _newMessage = string.Empty;
        _shouldScrollToBottom = true;
        await InvokeAsync(StateHasChanged);
        await ChatHubClient.SendMessageAsync(ThreadId, messageToSend);
    }

    public async ValueTask DisposeAsync()
    {
        if (ThreadId != null)
        {
            await ChatHubClient.LeaveThreadAsync(ThreadId);
        }
        ChatHubClient.MessageReceived -= OnMessageReceived;
        ChatHubClient.UserTyping -= OnUserTyping;
        ChatHubClient.MessageUpdated -= OnMessageUpdated;
        ChatHubClient.MessagePinned -= OnMessagePinned;
        ChatHubClient.MessageDeleted -= OnMessageDeleted;
        _typingTimer?.Dispose();
    }

    private async Task PinThread()
    {
        if (ThreadId != null)
        {
            await ChatHubClient.PinThreadAsync(ThreadId, !IsThreadPinned);
            IsThreadPinned = !IsThreadPinned;
        }
    }

    private async Task RequestNotificationPermission() => await JSRuntime.InvokeAsync<string>("cmetalsChat.requestNotificationPermission");

    private async Task OnUserTyping(TypingDto typingInfo)
    {
        if (typingInfo.ThreadId == ThreadId && typingInfo.UserId != _currentUserId)
        {
            if (typingInfo.IsTyping && !_participants.Any(p => p.Id == typingInfo.UserId))
            {
                // Simplified typing indicator logic
            }
        }
    }

    private async Task OnNewMessageInput(ChangeEventArgs e)
    {
        _newMessage = e.Value?.ToString() ?? string.Empty;
        await Task.Delay(1);
        var cursorPosition = await JSRuntime.InvokeAsync<int>("cmetalsChat.getCursorPosition", _messageInputId);
        var textBeforeCursor = _newMessage.Substring(0, cursorPosition);
        var lastAt = textBeforeCursor.LastIndexOf('@');
        var lastSpace = textBeforeCursor.LastIndexOf(' ');
        if (lastAt != -1 && lastAt > lastSpace)
        {
            _mentionStartPosition = lastAt;
            _mentionFilter = textBeforeCursor.Substring(lastAt + 1);
            _mentionSuggest?.Open();
        }
        else
        {
            _mentionSuggest?.Close();
        }
        if (ThreadId == null) return;
        if (_typingTimer == null)
        {
            _typingTimer = new Timer(1500);
            _typingTimer.Elapsed += async (sender, args) => {
                if(ThreadId != null) await ChatHubClient.TypingAsync(ThreadId, false);
                _typingSent = false;
                _typingTimer.Stop();
            };
            _typingTimer.AutoReset = false;
        }
        if (!_typingSent)
        {
            _typingSent = true;
            if(ThreadId != null) await ChatHubClient.TypingAsync(ThreadId, true);
        }
        _typingTimer.Stop();
        _typingTimer.Start();
    }

    private void OnUserMentioned(ApplicationUser user)
    {
        var before = _newMessage.Substring(0, _mentionStartPosition);
        var after = _newMessage.Substring(_mentionStartPosition + _mentionFilter.Length + 1);
        _newMessage = $"{before}@{user.UserName} {after}";
        _mentionSuggest?.Close();
    }

    private string GetInitials(string? name)
    {
        if (string.IsNullOrWhiteSpace(name)) return "?";
        var parts = name.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        return parts.Length > 1 ? $"{parts[0][0]}{parts[1][0]}".ToUpper() : $"{parts[0][0]}".ToUpper();
    }

    private async Task HandleFinishEditing(int messageId, string newContent) => await ChatHubClient.UpdateMessageAsync(messageId, newContent);
    private async Task HandlePinClicked(int messageId, bool isCurrentlyPinned) => await ChatHubClient.PinMessageAsync(messageId, !isCurrentlyPinned);
    private async Task HandleReactionClicked(int messageId, string emoji)
    {
        var message = _messages.FirstOrDefault(m => m.Id == messageId);
        if (message != null)
        {
            if (message.Reactions.TryGetValue(emoji, out var users) && users.Contains(_currentUserId!))
                await ChatHubClient.RemoveReactionAsync(messageId, emoji);
            else
                await ChatHubClient.AddReactionAsync(messageId, emoji);
        }
    }
    private async Task HandleDeleteClicked(int messageId)
    {
        var parameters = new DialogParameters { ["Title"] = "Delete Message", ["ContentText"] = "Are you sure you want to delete this message? This cannot be undone.", ["SubmitText"] = "Delete", ["CancelText"] = "Cancel" };
        var dialog = DialogService.Show<MudMessageBox>("Delete Message", parameters);
        var result = await dialog.Result;
        if (!result.Canceled)
            await ChatHubClient.DeleteMessageAsync(messageId);
    }
    private async Task OnMessagePinned(MessageDto message)
    {
        var oldPinned = _messages.FirstOrDefault(m => m.IsPinned);
        if (oldPinned != null) oldPinned.IsPinned = false;
        var newPinned = _messages.FirstOrDefault(m => m.Id == message.Id);
        if (newPinned != null) newPinned.IsPinned = message.IsPinned;
        await InvokeAsync(StateHasChanged);
    }
    private async Task OnMessageDeleted(int messageId)
    {
        _messages.RemoveAll(m => m.Id == messageId);
        await InvokeAsync(StateHasChanged);
    }
}
