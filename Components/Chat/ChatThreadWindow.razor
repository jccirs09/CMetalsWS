@namespace CMetalsWS.Components.Chat
@using CMetalsWS.Data
@using CMetalsWS.Services
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Identity
@using MudBlazor
@using Microsoft.AspNetCore.Components.Web
@using System.Security.Claims
@using System.Linq

@implements IAsyncDisposable

@inject IChatClient ChatClient
@inject IMessageStore MessageStore
@inject IJSRuntime JS

<div class="chat-thread-window @(IsMinimized ? "minimized" : "")" @onkeydown="HandleKeyDown">
    <MudPaper Class="chat" Elevation="6">
        <header class="chat__header" @onclick="@(async (MouseEventArgs _) => { if (IsMinimized) await OnMinimize.InvokeAsync(); })">
            <MudAvatar Class="mr-2"
                       Size="Size.Medium"
                       Color="@(Utils.ColorHelper.GetDeterministicColor(ThreadUser?.Id ?? string.Empty))"
                       Image="@(ThreadUser?.Avatar)"
                       Text="@((ThreadUser is not null && string.IsNullOrWhiteSpace(ThreadUser.Avatar)) ? $"{ThreadUser.FirstName?.FirstOrDefault()}{ThreadUser.LastName?.FirstOrDefault()}" : null)">
            </MudAvatar>
            <div class="chat__meta">
                <div class="chat__name">
                    @if (ThreadUser != null)
                    {
                        @ThreadUser.UserName
                    }
                    else if (ThreadGroup != null)
                    {
                        @ThreadGroup.Name
                    }
                </div>
                <div class="chat__status">@(ThreadUser?.IsOnline == true ? "Active now" : "Offline")</div>
            </div>
            <div class="ml-auto chat__actions">
                <MudIconButton Icon="@Icons.Material.Filled.Minimize" OnClick="@(async (MouseEventArgs _) => await OnMinimize.InvokeAsync())" />
                <MudIconButton Icon="@Icons.Material.Filled.Close" OnClick="@(async (MouseEventArgs _) => await OnClose.InvokeAsync())" />
            </div>
        </header>

        @if (!IsMinimized)
        {
            <div class="chat__messages"
                 @ref="_scrollArea"
                 @onwheel="OnMessagesWheel"
                 @onscroll="OnMessagesScrolled">
                @foreach (var m in _messages)
                {
                    var isOutgoing = m.SenderId == _currentUserId;
                    var dir = isOutgoing ? "out" : "in";
                    <div class="message @dir">
                        @if (!isOutgoing)
                        {
                            <MudAvatar Class="message__avatar" Size="Size.Small" Image="@m.Sender?.Avatar" />
                        }
                        <div>
                            <div class="bubble">@m.Content</div>
                            <div class="meta-row">
                                <span class="time">@m.Timestamp.ToLocalTime().ToString("h:mm tt")</span>
                                @if (isOutgoing)
                                {
                                    <span class="status-icons">
                                        @if (m.Delivered)
                                        {
                                            <MudIcon Icon="@Icons.Material.Filled.DoneAll" Class="delivered" />
                                        }
                                        else if (m.Sent)
                                        {
                                            <MudIcon Icon="@Icons.Material.Filled.Done" Class="sent" />
                                        }
                                    </span>

                                    @if (m.SeenBy?.Any() == true)
                                    {
                                        <span class="seen-avatars">
                                            @foreach (var u in m.SeenBy.Values)
                                            {
                                                <MudAvatar Class="seen-avatar" Size="Size.Small" Image="@u.Avatar" Text="@((u.Avatar is null || u.Avatar == "") ? $"{u.FirstName?.FirstOrDefault()}{u.LastName?.FirstOrDefault()}" : null)" />
                                            }
                                        </span>
                                    }
                                }
                            </div>
                        </div>
                    </div>
                }
                @if (_isTyping)
                {
                    <div class="message in">
                        <MudAvatar Class="message__avatar" Size="Size.Small" />
                        <div><div class="bubble">...</div></div>
                    </div>
                }
            </div>

            <EditForm Model="this" OnValidSubmit="SendMessageAsync">
                <div class="composer">
                    <MudTextField Value="@_draft"
                                  Placeholder="Type a message"
                                  Class="input"
                                  Lines="1"
                                  Immediate="true"
                                  OnKeyDown="HandleKeyDown"
                                  ValueChanged="@(EventCallback.Factory.Create<string>(this, OnDraftChanged))" />
                    <MudIconButton Icon="@Icons.Material.Filled.Send" Disabled="string.IsNullOrWhiteSpace(_draft)" ButtonType="ButtonType.Submit" />
                </div>
            </EditForm>
        }
    </MudPaper>
</div>

@code {
    [CascadingParameter] private Task<AuthenticationState> AuthState { get; set; } = default!;
    [Parameter] public ApplicationUser? ThreadUser { get; set; }
    [Parameter] public ChatGroup? ThreadGroup { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public EventCallback OnMinimize { get; set; }
    [Parameter] public bool IsMinimized { get; set; }

    private ElementReference _scrollArea;
    private string _draft = string.Empty;
    private string _currentUserId = "";
    private List<ChatMessage> _messages = new();
    private bool _isTyping = false;
    private bool _autoStickToBottom = true;
    private System.Timers.Timer? _typingTimer;
    private bool _typingSent;
    private bool _loadingOlder;
    private DateTime? _oldestLoaded;

    protected override async Task OnInitializedAsync()
    {
        var user = (await AuthState).User;
        _currentUserId = user.FindFirstValue(ClaimTypes.NameIdentifier)!;

        ChatClient.MessageReceived += OnMessageReceived;
        ChatClient.TypingChanged += OnTypingChanged;
        ChatClient.ReadReceipt += OnReadReceipt;

        if (ThreadUser != null)
        {
            var messages = await MessageStore.LoadUserThreadAsync(_currentUserId, ThreadUser.Id);
            _messages.AddRange(messages.Reverse());
        }
        else if (ThreadGroup != null)
        {
            var messages = await MessageStore.LoadGroupThreadAsync(ThreadGroup.Id);
            _messages.AddRange(messages.Reverse());
        }
    }

    private Task OnMessageReceived(ChatMessage message)
    {
        if (message.SenderId == _currentUserId)
        {
            var pending = _messages.FirstOrDefault(m => m.Sent && !m.Delivered && m.Content == message.Content);
            if (pending != null)
            {
                pending.Id = message.Id;
                pending.Delivered = true;
                return InvokeAsync(StateHasChanged);
            }
        }

        _messages.Add(message);
        if (_autoStickToBottom)
        {
            _ = ScrollToBottom();
        }
        return InvokeAsync(StateHasChanged);
    }

    private Task OnTypingChanged(string userId, bool isTyping)
    {
        if (ThreadUser != null && ThreadUser.Id == userId)
        {
            _isTyping = isTyping;
            return InvokeAsync(StateHasChanged);
        }
        return Task.CompletedTask;
    }

    private Task OnReadReceipt(int messageId, string userId)
    {
        var msg = _messages.FirstOrDefault(m => m.Id == messageId);
        if (msg != null)
        {
            if (ThreadGroup != null)
            {
                var user = ThreadGroup.ChatGroupUsers.FirstOrDefault(u => u.UserId == userId)?.User;
                if (user != null)
                    msg.SeenBy[user.Id] = user;
            }
            else if (ThreadUser != null)
            {
                msg.SeenBy[ThreadUser.Id] = ThreadUser;
            }
        }
        return InvokeAsync(StateHasChanged);
    }

    private Task OnMessagesScrolled(EventArgs _) => OnMessagesScrolledCore();
    private Task OnMessagesWheel(WheelEventArgs _) => OnMessagesScrolledCore();

    private async Task OnMessagesScrolledCore()
    {
        _autoStickToBottom = await JS.InvokeAsync<bool>("cmetalsChat.isNearBottom", _scrollArea, 64);
        if (_autoStickToBottom)
            await MaybeAckRead();

        var nearTop = await JS.InvokeAsync<bool>("cmetalsChat.isNearTop", _scrollArea, 24);
        if (nearTop && !_loadingOlder)
        {
            _loadingOlder = true;
            var before = _oldestLoaded ?? _messages.FirstOrDefault()?.Timestamp ?? DateTime.UtcNow;
            IReadOnlyList<ChatMessage> older;

            if (ThreadUser != null)
                older = await MessageStore.LoadUserThreadBeforeAsync(_currentUserId, ThreadUser.Id, before);
            else if (ThreadGroup != null)
                older = await MessageStore.LoadGroupThreadBeforeAsync(ThreadGroup.Id, before);
            else
                older = new List<ChatMessage>();

            if (older.Any())
            {
                _messages.InsertRange(0, older.Reverse());
                _oldestLoaded = older.First().Timestamp;
                await InvokeAsync(StateHasChanged);
            }
            _loadingOlder = false;
        }
    }

    private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(_draft)) return;

        var tempMsg = new ChatMessage
        {
            SenderId = _currentUserId,
            Content = _draft,
            Timestamp = DateTime.Now,
            Sent = true
        };
        _messages.Add(tempMsg);
        var toSend = _draft;
        _draft = string.Empty;
        if (_autoStickToBottom) await ScrollToBottom();
        await InvokeAsync(StateHasChanged);

        try
        {
            if (ThreadUser != null)
                await ChatClient.SendToUserAsync(ThreadUser.Id, toSend);
            else if (ThreadGroup != null)
                await ChatClient.SendToGroupAsync(ThreadGroup.Id, toSend);
        }
        catch { /* TODO: handle failed send */ }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            if (e.ShiftKey)
            {
                _draft += "\n";
            }
            else if (!string.IsNullOrWhiteSpace(_draft))
            {
                await SendMessageAsync();
            }
        }
        else if (e.Key == "Escape")
        {
            await OnClose.InvokeAsync();
        }
    }

    private async Task OnDraftChanged(string value)
    {
        _draft = value;
        if (!_typingSent)
        {
            _typingSent = true;
            if (ThreadUser != null)
                await ChatClient.SetTypingAsync(ThreadUser.Id, true);
        }

        _typingTimer?.Stop();
        _typingTimer = _typingTimer ?? new System.Timers.Timer(1200);
        _typingTimer.Interval = 1200;
        _typingTimer.AutoReset = false;
        _typingTimer.Elapsed += async (_, __) =>
        {
            try
            {
                if (ThreadUser != null)
                    await ChatClient.SetTypingAsync(ThreadUser.Id, false);
            }
            catch { /* ignore */ }
            finally { _typingSent = false; }
        };
        _typingTimer.Start();
    }

    private async Task MaybeAckRead()
    {
        if (_messages.Count == 0) return;
        var lastId = _messages[^1].Id;
        if (lastId == 0) return; // Don't ack optimistic message

        if (ThreadUser != null)
            await ChatClient.AckReadUserAsync(ThreadUser.Id, lastId);
        else if (ThreadGroup != null)
            await ChatClient.AckReadGroupAsync(ThreadGroup.Id, lastId);
    }

    private async Task ScrollToBottom()
    {
        await JS.InvokeVoidAsync("cmetalsChat.scrollToBottom", _scrollArea);
    }

    public async ValueTask DisposeAsync()
    {
        ChatClient.MessageReceived -= OnMessageReceived;
        ChatClient.TypingChanged -= OnTypingChanged;
        ChatClient.ReadReceipt -= OnReadReceipt;
        _typingTimer?.Dispose();
    }
}
