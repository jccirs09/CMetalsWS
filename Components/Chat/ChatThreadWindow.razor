@namespace CMetalsWS.Components.Chat
@using CMetalsWS.Data
@using CMetalsWS.Services
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.SignalR.Client
@using MudBlazor

@inject IChatService ChatService
@inject UserManager<ApplicationUser> UserManager
@inject AuthenticationStateProvider AuthStateProvider
@inject NavigationManager NavigationManager
@inject IJSRuntime JS

<div class="chat-thread-window @(IsMinimized ? "minimized" : "")" @onkeydown="HandleKeyDown">
    <MudPaper Class="chat" Elevation="6">
        <!-- Header -->
        <header class="chat__header" @onclick="() => { if(IsMinimized) OnMinimize.InvokeAsync(); }">
            <MudAvatar Class="mr-2" Size="Size.Medium" Color="@(Utils.ColorHelper.GetDeterministicColor(ThreadUser?.Id ?? string.Empty))">
                @if (ThreadUser != null && !string.IsNullOrEmpty(ThreadUser.Avatar))
                {
                    <MudImage Src="@ThreadUser.Avatar" />
                }
                else if (ThreadUser != null)
                {
                    @($"{ThreadUser.FirstName?.FirstOrDefault()}{ThreadUser.LastName?.FirstOrDefault()}")
                }
            </MudAvatar>
            <div class="chat__meta">
                <div class="chat__name">
                    @if (ThreadUser != null)
                    {
                        @ThreadUser.UserName
                    }
                    else if (ThreadGroup != null)
                    {
                        @ThreadGroup.Name
                    }
                </div>
                <div class="chat__status">@(ThreadUser?.IsOnline == true ? "Active now" : "Offline")</div>
                @if (ThreadGroup != null)
                {
                    <MudChip T="string" Size="Size.Small" Color="@(ThreadGroup.BranchId == null ? Color.Secondary : Color.Primary)">@(ThreadGroup.BranchId == null ? "Inter-branch" : "Intra-branch")</MudChip>
                }
            </div>
            <div class="ml-auto chat__actions">
                <MudIconButton Icon="@Icons.Material.Filled.Minimize" OnClick="@OnMinimize" />
                <MudIconButton Icon="@Icons.Material.Filled.Close" OnClick="@OnClose" />
            </div>
        </header>

        @if (!IsMinimized)
        {
            <!-- Messages -->
            <div class="chat__messages" @ref="_scrollArea">
                @foreach (var m in _messages)
                {
                    var isOutgoing = m.SenderId == _currentUserId;
                    var dir = isOutgoing ? "out" : "in";
                    <div class="message @dir">
                        @if (!isOutgoing)
                        {
                            <MudAvatar Class="message__avatar" Size="Size.Small" />
                        }
                        <div>
                            <div class="bubble">@m.Content</div>
                            <div class="meta-row">
                                <span class="time">@m.Timestamp.ToLocalTime().ToString("h:mm tt")</span>
                                @if (isOutgoing && m.Id == _lastSeenMessageId)
                                {
                                    <span class="seen">Seen</span>
                                }
                            </div>
                        </div>
                    </div>
                }
                @if (_isTyping)
                {
                    <div class="message in">
                        <MudAvatar Class="message__avatar" Size="Size.Small" />
                        <div>
                            <div class="bubble">...</div>
                        </div>
                    </div>
                }
            </div>

            <!-- Composer -->
            <EditForm Model="this" OnValidSubmit="SendMessageAsync">
                <div class="composer">
                    <MudTextField @bind-Value="_draft" Placeholder="Type a message" Class="input" Lines="1" Immediate="true" OnKeyDown="HandleEnter" />
                    <MudIconButton Icon="@Icons.Material.Filled.Send" Disabled="string.IsNullOrWhiteSpace(_draft)" ButtonType="ButtonType.Submit" />
                </div>
            </EditForm>

        <div class="sr-only" aria-live="polite">
            @foreach (var msg in _newMessagesForScreenReader)
            {
                <p>@msg</p>
            }
        </div>
        }
    </MudPaper>
</div>

@code {
    [Parameter] public ApplicationUser? ThreadUser { get; set; }
    [Parameter] public ChatGroup? ThreadGroup { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public EventCallback OnMinimize { get; set; }
    [Parameter] public bool IsMinimized { get; set; }

    private ElementReference _scrollArea;
    private string _draft = string.Empty;
    private string? _currentUserId;
    private List<ChatMessage> _messages = new();
    private HubConnection? _hubConnection;
    private bool _isTyping = false;
    private int _lastSeenMessageId = 0;
    private List<string> _newMessagesForScreenReader = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;
            if (user?.Identity?.IsAuthenticated == true)
            {
                _currentUserId = user.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
                if (_currentUserId != null)
                {
                    await LoadMessages();
                    await ConnectToHub();
                    StateHasChanged();
                }
            }
        }
    }

    private async Task LoadMessages()
    {
        if (ThreadUser != null)
        {
            _messages = await ChatService.GetConversationAsync(_currentUserId, ThreadUser.Id);
        }
        else if (ThreadGroup != null)
        {
            _messages = await ChatService.GetGroupConversationAsync(ThreadGroup.Id);
        }
    }

    private async Task ConnectToHub()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/chat"))
            .Build();

        _hubConnection.On<string, string>("ReceiveMessage", async (userId, message) =>
        {
            if ((ThreadUser != null && ThreadUser.Id == userId) || userId == _currentUserId)
            {
                var sender = await ChatService.GetUserDetailsAsync(userId);
                var chatMessage = new ChatMessage { SenderId = userId, Sender = sender, Content = message, Timestamp = DateTime.Now };
                _messages.Add(chatMessage);
                _newMessagesForScreenReader.Add($"{sender?.UserName}: {message}");
                await InvokeAsync(StateHasChanged);
                await ScrollToBottom();
                await ClearNewMessagesForScreenReader();
            }
        });

        _hubConnection.On<string, int, string>("ReceiveGroupMessage", async (userId, groupId, message) =>
        {
            if (ThreadGroup != null && ThreadGroup.Id == groupId)
            {
                var sender = await ChatService.GetUserDetailsAsync(userId);
                var chatMessage = new ChatMessage { SenderId = userId, Sender = sender, ChatGroupId = groupId, Content = message, Timestamp = DateTime.Now };
                _messages.Add(chatMessage);
                _newMessagesForScreenReader.Add($"{sender?.UserName} in {ThreadGroup.Name}: {message}");
                await InvokeAsync(StateHasChanged);
                await ScrollToBottom();
                await ClearNewMessagesForScreenReader();
            }
        });

        _hubConnection.On<string, bool>("ReceiveTypingState", (userId, isTyping) =>
        {
            if (ThreadUser != null && ThreadUser.Id == userId)
            {
                _isTyping = isTyping;
                InvokeAsync(StateHasChanged);
            }
        });

        _hubConnection.On<int>("ReceiveReadReceipt", messageId =>
        {
            _lastSeenMessageId = messageId;
            InvokeAsync(StateHasChanged);
        });

        await _hubConnection.StartAsync();
    }

    private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(_draft) || _hubConnection == null) return;

        if (ThreadUser != null)
        {
            await _hubConnection.SendAsync("SendMessageToUser", ThreadUser.Id, _draft);
        }
        else if (ThreadGroup != null)
        {
            await _hubConnection.SendAsync("SendMessageToGroup", ThreadGroup.Id, _draft);
        }
        _draft = string.Empty;
        StateHasChanged();
    }

    private void HandleEnter(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(_draft))
        {
            _ = SendMessageAsync();
        }
    }

    private async Task ScrollToBottom()
    {
        await Task.Delay(10);
        await JS.InvokeVoidAsync("(el)=>{el.scrollTop = el.scrollHeight;}", _scrollArea);
    }

    private async Task ClearNewMessagesForScreenReader()
    {
        await Task.Delay(5000); // Wait 5 seconds
        _newMessagesForScreenReader.Clear();
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Escape")
        {
            await OnClose.InvokeAsync();
        }
    }
}
