@namespace CMetalsWS.Components.Chat
@using CMetalsWS.Data
@using CMetalsWS.Services
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.SignalR.Client
@using MudBlazor

@inject IChatService ChatService
@inject UserManager<ApplicationUser> UserManager
@inject AuthenticationStateProvider AuthStateProvider
@inject NavigationManager NavigationManager
@inject IJSRuntime JS

<div class="chat-thread-window @(IsMinimized ? "minimized" : "")" @onkeydown="HandleKeyDown">
    <MudPaper Class="chat" Elevation="6">
        <!-- Header -->
        <header class="chat__header" @onclick="() => { if(IsMinimized) OnMinimize.InvokeAsync(); }">
            <MudAvatar Class="mr-2" Size="Size.Medium" Color="@(Utils.ColorHelper.GetDeterministicColor(ThreadUser?.Id ?? string.Empty))">
                @if (ThreadUser != null && !string.IsNullOrEmpty(ThreadUser.Avatar))
                {
                    <MudImage Src="@ThreadUser.Avatar" />
                }
                else if (ThreadUser != null)
                {
                    @($"{ThreadUser.FirstName?.FirstOrDefault()}{ThreadUser.LastName?.FirstOrDefault()}")
                }
            </MudAvatar>
            <div class="chat__meta">
                <div class="chat__name">
                    @if (ThreadUser != null)
                    {
                        @ThreadUser.UserName
                    }
                    else if (ThreadGroup != null)
                    {
                        @ThreadGroup.Name
                    }
                </div>
                <div class="chat__status">@(ThreadUser?.IsOnline == true ? "Active now" : "Offline")</div>
                @if (ThreadGroup != null)
                {
                    <MudChip T="string" Size="Size.Small" Color="@(ThreadGroup.BranchId == null ? Color.Secondary : Color.Primary)">@(ThreadGroup.BranchId == null ? "Inter-branch" : "Intra-branch")</MudChip>
                }
            </div>
            <div class="ml-auto chat__actions">
                <MudIconButton Icon="@Icons.Material.Filled.Minimize" OnClick="@OnMinimize" />
                <MudIconButton Icon="@Icons.Material.Filled.Close" OnClick="@OnClose" />
            </div>
        </header>

        @if (!IsMinimized)
        {
            <!-- Messages -->
            <div class="chat__messages" @ref="_scrollArea" @onwheel="OnMessagesScrolled" @onscroll="OnMessagesScrolled">
                @foreach (var m in _messages)
                {
                    var isOutgoing = m.SenderId == _currentUserId;
                    var dir = isOutgoing ? "out" : "in";
                    <div class="message @dir">
                        @if (!isOutgoing)
                        {
                            <MudAvatar Class="message__avatar" Size="Size.Small" />
                        }
                        <div>
                            <div class="bubble">@m.Content</div>
                            <div class="meta-row">
                                <span class="time">@m.Timestamp.ToLocalTime().ToString("h:mm tt")</span>
                                @if (isOutgoing && m.Id == _lastSeenMessageId)
                                {
                                    <span class="seen">Seen</span>
                                }
                            </div>
                        </div>
                    </div>
                }
                @if (_isTyping)
                {
                    <div class="message in">
                        <MudAvatar Class="message__avatar" Size="Size.Small" />
                        <div>
                            <div class="bubble">...</div>
                        </div>
                    </div>
                }
            </div>

            <!-- Composer -->
            <EditForm Model="this" OnValidSubmit="SendMessageAsync">
                <div class="composer">
                    <MudTextField @bind-Value="_draft" Placeholder="Type a message" Class="input" Lines="1" Immediate="true" OnKeyDown="HandleEnter" ValueChanged="OnDraftChanged" />
                    <MudIconButton Icon="@Icons.Material.Filled.Send" Disabled="string.IsNullOrWhiteSpace(_draft)" ButtonType="ButtonType.Submit" />
                </div>
            </EditForm>

        <div class="sr-only" aria-live="polite">
            @foreach (var msg in _newMessagesForScreenReader)
            {
                <p>@msg</p>
            }
        </div>
        }
    </MudPaper>
</div>

@implements IAsyncDisposable

@code {
    [Parameter] public ApplicationUser? ThreadUser { get; set; }
    [Parameter] public ChatGroup? ThreadGroup { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public EventCallback OnMinimize { get; set; }
    [Parameter] public bool IsMinimized { get; set; }

    private ElementReference _scrollArea;
    private string _draft = string.Empty;
    private string? _currentUserId;
    private List<ChatMessage> _messages = new();
    private HubConnection? _hubConnection;
    private bool _isTyping = false;
    private int _lastSeenMessageId = 0;
    private List<string> _newMessagesForScreenReader = new();
    private bool _autoStickToBottom = true;
    private System.Timers.Timer? _typingTimer;
    private bool _typingSent;
    private bool _loadingOlder;
    private DateTime? _oldestLoaded;

    private async Task OnMessagesScrolled()
    {
        // stickiness
        _autoStickToBottom = await JS.InvokeAsync<bool>("cmetalsChat.isNearBottom", _scrollArea, 64);
        if (_autoStickToBottom)
        {
            await MaybeAckRead();
        }

        // near top? load older
        var nearTop = await JS.InvokeAsync<bool>("cmetalsChat.isNearTop", _scrollArea, 24);
        if (nearTop && !_loadingOlder)
        {
            _loadingOlder = true;
            var before = _oldestLoaded ?? _messages.FirstOrDefault()?.Timestamp ?? DateTime.UtcNow;
            List<ChatMessage> older;

            if (ThreadUser != null)
                older = await ChatService.GetConversationBeforeAsync(_currentUserId, ThreadUser.Id, before);
            else if (ThreadGroup != null)
                older = await ChatService.GetGroupConversationBeforeAsync(ThreadGroup.Id, before);
            else
                older = new();

            if (older.Count > 0)
            {
                // remember scroll height to maintain position
                var prevHeight = await JS.InvokeAsync<int>("eval", "document.querySelector('.chat__messages').scrollHeight"); // or write a helper
                _messages.InsertRange(0, older);
                _oldestLoaded = older.First().Timestamp;

                await InvokeAsync(StateHasChanged);
                // maintain position (optional advanced work)
            }

            _loadingOlder = false;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var user = authState.User;
            if (user?.Identity?.IsAuthenticated == true)
            {
                _currentUserId = user.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
                if (_currentUserId != null)
                {
                    await LoadMessages();
                    await ConnectToHub();
                    StateHasChanged();
                }
            }
        }
    }

    private async Task LoadMessages()
    {
        if (ThreadUser != null)
        {
            _messages = await ChatService.GetConversationAsync(_currentUserId, ThreadUser.Id);
        }
        else if (ThreadGroup != null)
        {
            _messages = await ChatService.GetGroupConversationAsync(ThreadGroup.Id);
        }
    }

    private async Task ConnectToHub()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/hubs/chat"))
            .WithAutomaticReconnect()
            .Build();

        _hubConnection.On<string, string>("ReceiveMessage", async (userId, message) =>
        {
            if ((ThreadUser != null && ThreadUser.Id == userId) || userId == _currentUserId)
            {
                var sender = await ChatService.GetUserDetailsAsync(userId);
                var chatMessage = new ChatMessage { SenderId = userId, Sender = sender, Content = message, Timestamp = DateTime.Now };
                _messages.Add(chatMessage);
                _newMessagesForScreenReader.Add($"{sender?.UserName}: {message}");
                await InvokeAsync(StateHasChanged);
                    if (_autoStickToBottom)
                    {
                        await ScrollToBottom();
                        await MaybeAckRead();
                    }
                await ClearNewMessagesForScreenReader();
            }
        });

        _hubConnection.On<string, int, string>("ReceiveGroupMessage", async (userId, groupId, message) =>
        {
            if (ThreadGroup != null && ThreadGroup.Id == groupId)
            {
                var sender = await ChatService.GetUserDetailsAsync(userId);
                var chatMessage = new ChatMessage { SenderId = userId, Sender = sender, ChatGroupId = groupId, Content = message, Timestamp = DateTime.Now };
                _messages.Add(chatMessage);
                _newMessagesForScreenReader.Add($"{sender?.UserName} in {ThreadGroup.Name}: {message}");
                await InvokeAsync(StateHasChanged);
                    if (_autoStickToBottom)
                    {
                        await ScrollToBottom();
                    await MaybeAckRead();
                    }
                await ClearNewMessagesForScreenReader();
            }
        });

        _hubConnection.On<string, bool>("ReceiveTypingState", (userId, isTyping) =>
        {
            if (ThreadUser != null && ThreadUser.Id == userId)
            {
                _isTyping = isTyping;
                InvokeAsync(StateHasChanged);
            }
        });

        _hubConnection.On<int>("ReceiveReadReceipt", messageId =>
        {
            _lastSeenMessageId = messageId;
            InvokeAsync(StateHasChanged);
        });

        await _hubConnection.StartAsync();
    }

    private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(_draft) || _hubConnection == null) return;

        var pending = new ChatMessage {
            Id = 0, // temp
            SenderId = _currentUserId!,
            Content = _draft,
            Timestamp = DateTime.Now
        };

        _messages.Add(pending);
        var toSend = _draft;
        _draft = string.Empty;
        StateHasChanged();
        if (_autoStickToBottom) await ScrollToBottom();

        try
        {
            if (ThreadUser != null)
                await _hubConnection.SendAsync("SendMessageToUser", ThreadUser.Id, toSend);
            else if (ThreadGroup != null)
                await _hubConnection.SendAsync("SendMessageToGroup", ThreadGroup.Id, toSend);
        }
        catch
        {
            // mark pending as failed or pop a snackbar
        }
    }

    private void HandleEnter(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            if (e.ShiftKey)
            {
                _draft += "\n";
            }
            else if (!string.IsNullOrWhiteSpace(_draft))
            {
                _ = SendMessageAsync();
            }
        }
    }

    private async Task ScrollToBottom()
    {
        await Task.Delay(10);
        await JS.InvokeVoidAsync("cmetalsChat.scrollToBottom", _scrollArea);
    }

    private async Task ClearNewMessagesForScreenReader()
    {
        await Task.Delay(5000); // Wait 5 seconds
        _newMessagesForScreenReader.Clear();
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Escape")
        {
            await OnClose.InvokeAsync();
        }
    }

    private async Task OnDraftChanged(string value)
    {
        _draft = value;

        if (!_typingSent)
        {
            _typingSent = true;
            if (ThreadUser != null)
                await _hubConnection!.SendAsync("SetTypingStateForUser", ThreadUser.Id, true);
            else if (ThreadGroup != null)
                await _hubConnection!.SendAsync("SetTypingStateForGroup", ThreadGroup.Id, true);
        }

        _typingTimer?.Stop();
        _typingTimer = _typingTimer ?? new System.Timers.Timer(1200);
        _typingTimer.Interval = 1200;
        _typingTimer.AutoReset = false;
        _typingTimer.Elapsed += async (_, __) =>
        {
            try
            {
                if (ThreadUser != null)
                    await _hubConnection!.SendAsync("SetTypingStateForUser", ThreadUser.Id, false);
                else if (ThreadGroup != null)
                    await _hubConnection!.SendAsync("SetTypingStateForGroup", ThreadGroup.Id, false);
            }
            catch { /* ignore */ }
            finally { _typingSent = false; }
        };
        _typingTimer.Start();
    }

    private async Task MaybeAckRead()
    {
        if (_messages.Count == 0) return;
        // last message Id in the active thread
        var lastId = _messages[^1].Id;

        if (ThreadUser != null)
            await _hubConnection!.SendAsync("AckReadUser", ThreadUser.Id, lastId);
        else if (ThreadGroup != null)
            await _hubConnection!.SendAsync("AckReadGroup", ThreadGroup.Id, lastId);
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection is not null)
        {
            try { await _hubConnection.StopAsync(); }
            finally { await _hubConnection.DisposeAsync(); }
        }
    }
}
