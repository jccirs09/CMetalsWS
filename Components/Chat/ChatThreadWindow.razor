@namespace CMetalsWS.Components.Chat
@using CMetalsWS.Data
@using CMetalsWS.Services
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Identity
@using MudBlazor
@using Microsoft.AspNetCore.Components.Web
@using System.Security.Claims

@implements IAsyncDisposable

@inject IChatClient ChatClient
@inject IMessageStore MessageStore
@inject IJSRuntime JS

<div class="chat-thread-window @(IsMinimized ? "minimized" : "")" @onkeydown="HandleKeyDown">
    <MudPaper Class="chat" Elevation="6">
        <header class="chat__header" @onclick="@(async (MouseEventArgs _) => { if (IsMinimized) await OnMinimize.InvokeAsync(); })">
            <MudAvatar Class="mr-2"
                       Size="Size.Medium"
                       Color="@(Utils.ColorHelper.GetDeterministicColor(ThreadUser?.Id ?? string.Empty))"
                       Image="@(ThreadUser?.Avatar)"
                       Text="@((ThreadUser is not null && string.IsNullOrWhiteSpace(ThreadUser.Avatar)) ? $"{ThreadUser.FirstName?.FirstOrDefault()}{ThreadUser.LastName?.FirstOrDefault()}" : null)">
            </MudAvatar>
            <div class="chat__meta">
                <div class="chat__name">
                    @if (ThreadUser != null)
                    {
                        @ThreadUser.UserName
                    }
                    else if (ThreadGroup != null)
                    {
                        @ThreadGroup.Name
                    }
                </div>
                <div class="chat__status">@(ThreadUser?.IsOnline == true ? "Active now" : "Offline")</div>
            </div>
            <div class="ml-auto chat__actions">
                <MudIconButton Icon="@Icons.Material.Filled.Minimize" OnClick="@(async (MouseEventArgs _) => await OnMinimize.InvokeAsync())" />
                <MudIconButton Icon="@Icons.Material.Filled.Close" OnClick="@(async (MouseEventArgs _) => await OnClose.InvokeAsync())" />
            </div>
        </header>

        @if (!IsMinimized)
        {
            <div class="chat__messages"
                 @ref="_scrollArea"
                 @onwheel="OnMessagesWheel"
                 @onscroll="OnMessagesScrolled">
                @foreach (var m in _messages)
                {
                    var isOutgoing = m.SenderId == _currentUserId;
                    <MudChat ChatPosition="@(isOutgoing ? ChatBubblePosition.End : ChatBubblePosition.Start)" ArrowPosition="ChatArrowPosition.Bottom">
                        <MudChatBubble>
                            @if (!isOutgoing)
                            {
                                <MudChatHeader>
                                    <MudAvatar Size="Size.Small" Image="@m.Sender?.Avatar" />
                                </MudChatHeader>
                            }
                            @m.Content
                            <MudChatFooter>
                                <span>@m.Timestamp.ToLocalTime().ToString("h:mm tt")</span>
                                @if (isOutgoing && m.Id == _lastSeenMessageId && ThreadUser != null)
                                {
                                    <MudAvatar Class="seen-avatar"
                                               Size="Size.Small"
                                               Style="width:16px;height:16px;"
                                               Image="@ThreadUser.Avatar"
                                               Text="@((string.IsNullOrWhiteSpace(ThreadUser.Avatar)) ? $"{ThreadUser.FirstName?.FirstOrDefault()}{ThreadUser.LastName?.FirstOrDefault()}" : null)" />
                                }
                            </MudChatFooter>
                        </MudChatBubble>
                    </MudChat>
                }
                @if (_isTyping)
                {
                    <MudChat ChatPosition="ChatBubblePosition.Start" ArrowPosition="ChatArrowPosition.Bottom">
                        <MudChatBubble>
                            <MudChatHeader>
                                <MudAvatar Size="Size.Small" />
                            </MudChatHeader>
                            <span>...</span>
                        </MudChatBubble>
                    </MudChat>
                }
            </div>

            <EditForm Model="this" OnValidSubmit="SendMessageAsync">
                <div class="composer">
                    <MudTextField T="string" Value="@_draft"
                                  ValueChanged="@OnDraftChanged"
                                  Placeholder="Type a message"
                                  Class="input"
                                  Lines="1"
                                  Immediate="true"
                                  OnKeyDown="HandleKeyDown"
                                  @ref="_inputRef" />
                    <MudIconButton Icon="@Icons.Material.Filled.Send" Disabled="string.IsNullOrWhiteSpace(_draft)" ButtonType="ButtonType.Submit" />
                </div>
            </EditForm>
        }
    </MudPaper>
</div>

@code {
    [CascadingParameter] private Task<AuthenticationState> AuthState { get; set; } = default!;
    [Parameter] public ApplicationUser? ThreadUser { get; set; }
    [Parameter] public ChatGroup? ThreadGroup { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public EventCallback OnMinimize { get; set; }
    [Parameter] public bool IsMinimized { get; set; }

    private ElementReference _scrollArea;
    private string _draft = string.Empty;
    private string _currentUserId = "";
    private List<ChatMessage> _messages = new();
    private bool _isTyping = false;
    private int _lastSeenMessageId = 0;
    private bool _autoStickToBottom = true;
    private System.Timers.Timer? _typingTimer;
    private bool _typingSent;
    private bool _loadingOlder;
    private DateTime? _oldestLoaded;
    private MudTextField<string>? _inputRef;

    protected override async Task OnInitializedAsync()
    {
        await ChatClient.ConnectAsync();
        var user = (await AuthState).User;
        _currentUserId = user.FindFirstValue(ClaimTypes.NameIdentifier)!;

        ChatClient.MessageReceived += OnMessageReceived;
        ChatClient.TypingChanged += OnTypingChanged;
        ChatClient.ReadReceipt += OnReadReceipt;

        if (ThreadUser != null)
        {
            var messages = await MessageStore.LoadUserThreadAsync(_currentUserId, ThreadUser.Id);
            _messages.AddRange(messages.Reverse());
        }
        else if (ThreadGroup != null)
        {
            var messages = await MessageStore.LoadGroupThreadAsync(ThreadGroup.Id);
            _messages.AddRange(messages.Reverse());
        }
    }

    private Task OnMessageReceived(ChatMessage message)
    {
        _messages.Add(message);
        if (_autoStickToBottom)
        {
            _ = ScrollToBottom();
        }
        return InvokeAsync(StateHasChanged);
    }

    private Task OnTypingChanged(string userId, bool isTyping)
    {
        if (ThreadUser != null && ThreadUser.Id == userId)
        {
            _isTyping = isTyping;
            return InvokeAsync(StateHasChanged);
        }
        return Task.CompletedTask;
    }

    private Task OnReadReceipt(int messageId)
    {
        _lastSeenMessageId = messageId;
        return InvokeAsync(StateHasChanged);
    }

    private Task OnMessagesScrolled(EventArgs _) => OnMessagesScrolledCore();
    private Task OnMessagesWheel(WheelEventArgs _) => OnMessagesScrolledCore();

    private async Task OnMessagesScrolledCore()
    {
        _autoStickToBottom = await JS.InvokeAsync<bool>("cmetalsChat.isNearBottom", _scrollArea, 64);
        if (_autoStickToBottom)
            await MaybeAckRead();

        var nearTop = await JS.InvokeAsync<bool>("cmetalsChat.isNearTop", _scrollArea, 24);
        if (nearTop && !_loadingOlder)
        {
            _loadingOlder = true;
            var before = _oldestLoaded ?? _messages.FirstOrDefault()?.Timestamp ?? DateTime.UtcNow;
            IReadOnlyList<ChatMessage> older;

            if (ThreadUser != null)
                older = await MessageStore.LoadUserThreadBeforeAsync(_currentUserId, ThreadUser.Id, before);
            else if (ThreadGroup != null)
                older = await MessageStore.LoadGroupThreadBeforeAsync(ThreadGroup.Id, before);
            else
                older = new List<ChatMessage>();

            if (older.Any())
            {
                _messages.InsertRange(0, older.Reverse());
                _oldestLoaded = older.First().Timestamp;
                await InvokeAsync(StateHasChanged);
            }
            _loadingOlder = false;
        }
    }

    private async Task SendMessageAsync()
    {
        if (string.IsNullOrWhiteSpace(_draft)) return;

        var tempMsg = new ChatMessage
        {
            SenderId = _currentUserId,
            Content = _draft,
            Timestamp = DateTime.Now
        };
        _messages.Add(tempMsg);
        var toSend = _draft;
        _draft = string.Empty;
        if (_autoStickToBottom) await ScrollToBottom();
        await InvokeAsync(StateHasChanged);

        try
        {
            if (ThreadUser != null)
                await ChatClient.SendToUserAsync(ThreadUser.Id, toSend);
            else if (ThreadGroup != null)
                await ChatClient.SendToGroupAsync(ThreadGroup.Id, toSend);
        }
        catch { /* TODO: handle failed send */ }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            if (e.ShiftKey)
            {
                _draft += "\n";
            }
            else if (!string.IsNullOrWhiteSpace(_draft))
            {
                await SendMessageAsync();
            }
        }
        else if (e.Key == "Escape")
        {
            await OnClose.InvokeAsync();
        }
    }

    private async Task OnDraftChanged(string value)
    {
        _draft = value;
        if (!_typingSent)
        {
            _typingSent = true;
            if (ThreadUser != null)
            {
                try
                {
                    await ChatClient.SetTypingAsync(ThreadUser.Id, true);
                }
                catch
                {
                    _typingSent = false;
                }
            }
        }

        _typingTimer?.Stop();
        _typingTimer = _typingTimer ?? new System.Timers.Timer(1200);
        _typingTimer.Interval = 1200;
        _typingTimer.AutoReset = false;
        _typingTimer.Elapsed += async (_, __) =>
        {
            try
            {
                if (ThreadUser != null)
                    await ChatClient.SetTypingAsync(ThreadUser.Id, false);
            }
            catch { /* ignore */ }
            finally { _typingSent = false; }
        };
        _typingTimer.Start();
    }

    private async Task MaybeAckRead()
    {
        if (_messages.Count == 0) return;
        var lastId = _messages[^1].Id;
        if (lastId == 0) return; // Don't ack optimistic message

        if (ThreadUser != null)
            await ChatClient.AckReadUserAsync(ThreadUser.Id, lastId);
        else if (ThreadGroup != null)
            await ChatClient.AckReadGroupAsync(ThreadGroup.Id, lastId);
    }

    private async Task ScrollToBottom()
    {
        await JS.InvokeVoidAsync("cmetalsChat.scrollToBottom", _scrollArea);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _inputRef != null)
        {
            await _inputRef.FocusAsync();
        }
    }

    public async ValueTask DisposeAsync()
    {
        ChatClient.MessageReceived -= OnMessageReceived;
        ChatClient.TypingChanged -= OnTypingChanged;
        ChatClient.ReadReceipt -= OnReadReceipt;
        _typingTimer?.Dispose();
    }
}
